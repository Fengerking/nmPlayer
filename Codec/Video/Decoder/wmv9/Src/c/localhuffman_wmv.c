//*@@@+++@@@@******************************************************************
//
// Microsoft Windows Media
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//*@@@---@@@@******************************************************************
/*************************************************************************

Copyright (c) 1996 -- 2000  Microsoft Corporation

Module Name:

    localHuffman.cpp

Abstract:

    Local Huffman code generator.

Revision History:

    Sridhar Srinivasan: 3/16/00

*************************************************************************/
#include "xplatform_wmv.h"
#include "typedef.h"
#include "wmvdec_api.h"
#include "localhuffman_wmv.h"
#include "wmvdec_function.h"


// fineTbl counts bit for "last"
static const U8_WMV fineTbl[] = {
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,
    /* L0 */ 3,3, 2,3, 5,4,  2,2,2,3,3,  2,3,
    /* L1 */ 2,2,2,2,4,4, 2,3,4,  2,3,4,  2,3,
    /* Q0 */ 5, 5, 11, 14
};


static const U8_WMV fineTblMV[] = {2,3,4,5,8,  2,4,5,6,7,10,  3,5,6,7,8,11,
                               4,6,7,8,9,12, 5,7,8,9,10,13, 8,10,11,12,13,17, 0,
                               0,2,3,4,5,8,  2,4,5,6,7,10,  3,5,6,7,8,11,
                               4,6,7,8,9,12, 5,7,8,9,10,13, 8,10,11,12,13,17, 0,
                               // half pel table
                               2,3,4,5,7,  2,4,5,6,7,9,  3,5,6,7,8,10,
                               4,6,7,8,9,11, 5,7,8,9,10,12, 7,9,10,11,12,15, 0,
                               0,2,3,4,5,7,  2,4,5,6,7,9,  3,5,6,7,8,10,
                               4,6,7,8,9,11, 5,7,8,9,10,12, 7,9,10,11,12,15, 0,};


static const U8_WMV fineTblJoint[] = {0,1,1,1,1, 2,2, 3,3, 4,4, 5,5, 6,6, 7,7,
                     0,1,1,1,1, 2,2, 3,3, 4,4, 5,5, 6,6, 7,7};

static const I32_WMV iLaplacianAlphabet = 17;
static const U8_WMV aNulls[]={0,0,0,0,0,0,0,0,0,0,0,0};
static const U8_WMV gacCodeLengthsJoint[]={
                3,3,4,5,6,6,7,8,8,9,10,12,13,13,13,13,13,
                2,2,4,5,8,8,9,10,13,13,13,13,13,13,13,13,13};

/**********************************************************************
 generateHuffman_balanced : generates optimum huffman code lengths
 for balanced codeword lengths
 Maximum codeword length allowed = 20
**********************************************************************/

static Void_WMV generateHuffman_balanced(tPackHuffmanCode_WMV *pCodeTable, I32_WMV iN)
{
    const I32_WMV iMaxLength = 20;
    I32_WMV i;
    I32_WMV  iLowest = 0;
    I32_WMV  pNextCode [20];
    DEBUG_PROFILE_FRAME_FUNCTION_COUNT(generateHuffman_balanced);

    pCodeTable->code = iN;
    pCodeTable++;

    // set all next codes to 0
    memset (pNextCode, 0, sizeof(pNextCode));
    pNextCode[0] = 1 << iMaxLength;
 
    for (i = 0; i < iN; i++) {

        // first set output codeword
        I32_WMV  iLen, iCode, iNewCode, iLSB, j;

        iLen = pCodeTable->length;
        iCode = pNextCode[iLen];
        // actual codeword is shifted appropriately
        pCodeTable->code = iCode >> (iMaxLength - iLen);
        pCodeTable++;

        // test last bit : if 1, set to next shorter code
        iLSB = 1 << (iMaxLength - iLen);
        if (iCode & iLSB)
            iNewCode = pNextCode[iLen - 1];
        else
            iNewCode = iCode + iLSB;

        pNextCode[iLen] = iNewCode;
        if (iNewCode == (1 << iMaxLength))
            iLowest = iLen;

        // for all shorter codewords, check if same - add
        for (j = iLen - 1; j > iLowest; j--) {
            if (pNextCode[j] != iCode)
                break;

            iLSB <<= 1;
            if (pNextCode[j] & iLSB)
                pNextCode[j] = pNextCode[j - 1];
            else
                pNextCode[j] += iLSB;

            if (pNextCode[j] == (1 << iMaxLength))
                iLowest = j;
        }

        // for all longer codewords, check if same - add
        for (j = iLen + 1; j < iMaxLength; j++) {
            if (pNextCode[j] != iCode)
                break;
            pNextCode[j] = iNewCode;
        }
    }
}

U8_WMV zigzagArray[]={0,2,0,1, 1,1,0,2, 2,0, 1,2};

/**********************************************************************************
  Code length arrays : packed arrays
  Author:   Sridhar Srinivasan
  Updated:  4/20/2001
**********************************************************************************/
static U8_WMV gacCodeLengthsOrientLowRate[] = {
1,
0x11,0x22,0x52,0x54,0x55,0x55,
0x10,0x42,0x64,0x65,0x66,0x66,
};

static U8_WMV gacCodeLengthsOrientHighRate[] = {
2,
0x20,0x32,0x53,0x54,0x55,0x55,
0x44,0x14,0x31,0x24,0x33,0x44,
0x11,0x22,0x52,0x45,0x55,0x55,
0x32,0x13,0x41,0x34,0x44,0x44,
};

static U8_WMV gacCodeLengthsInterLowRate[] = {
3,
0x32,0x55,0x56,0x7e,0x8e,0x8e,0xee,0xde,0x54,0x88,0x66,0x18,0x32,0x43,0x75,0x56,0x76,0x6d,0x66,0x48,0x85,0x87,0xd8,0xdd,0xd7,0xdd,0xdd,0xdd,0xdd,0x8d,0xdd,0xdd,0xdd,0xd8,0xd8,0xdd,0x8d,0xdd,0x2d,
0x32,0x43,0x55,0x55,0x76,0x77,0xd7,0x99,0x43,0x65,0x54,0x34,0x44,0x55,0x55,0x65,0x77,0x66,0x66,0x67,0x76,0x77,0x9d,0xd8,0x84,0xdd,0x74,0xdd,0x5d,0x67,0x87,0xd7,0x7d,0xd8,0xdd,0x8d,0x4d,0x87,0x3d,
0x43,0xbb,0xbb,0xbb,0xbb,0xbb,0xaa,0xaa,0xaa,0xaa,0xaa,0xa,0x41,0x44,0xaa,0xaa,0xaa,0xaa,0xaa,0x4a,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0x7a,
0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x7,0x67,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x86,
0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x17,0x70,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x97,
0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x88,0x8,0x82,0x18,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x18,
0x31,0x44,0x55,0x76,0x77,0x88,0x89,0xe9,0x42,0x55,0x63,0x44,0x66,0x76,0x66,0x77,0x77,0x77,0x87,0x77,0x87,0x9e,0x99,0x9e,0x85,0xee,0x53,0xe9,0x5d,0xd7,0xd9,0xdd,0x7d,0x99,0xdd,0xdd,0x4d,0xd9,0x2d,
0x32,0x44,0x75,0x56,0xc6,0x77,0xcc,0x7c,0x43,0x56,0x65,0x25,0x44,0x53,0x55,0x74,0x55,0x55,0x77,0x46,0x66,0x6c,0xc7,0xcc,0x66,0xcc,0xc7,0xcc,0x7c,0x6c,0xc7,0xcc,0x7c,0xcc,0xcc,0x7c,0x5b,0xbb,0xfb,
};

static U8_WMV gacCodeLengthsInterHighRate[] = {
3,
0x21,0x43,0x65,0x66,0x78,0x77,0x99,0x99,0x63,0x98,0x65,0x36,0x43,0x44,0x55,0x55,0x66,0x66,0x66,0x76,0x98,0xdd,0xdd,0xd9,0xd8,0xdd,0xd7,0xdd,0x9d,0x6d,0x77,0xd8,0xdd,0xdd,0xdd,0xdd,0xcc,0xcc,0x2c,
0x42,0x56,0x75,0x77,0xdd,0xd6,0xdd,0xdd,0x75,0x7d,0xdd,0x1d,0x42,0x33,0x53,0x66,0x66,0x67,0x55,0x55,0xd7,0x77,0xd7,0xdd,0xd7,0xdd,0xcc,0xcc,0xcc,0x5c,0xcc,0xcc,0x6c,0xcc,0xcc,0xcc,0xcc,0xcc,0x1c,
0x21,0x32,0x44,0x55,0x66,0x76,0x77,0x98,0x53,0x87,0x85,0x47,0x55,0x65,0x66,0x66,0x66,0x66,0x66,0xf7,0xef,0xeb,0xee,0x97,0xb8,0xee,0xe7,0xee,0x8e,0x6e,0x77,0xba,0xee,0xee,0xee,0xee,0x8e,0xee,0x1e,
0x21,0x43,0x54,0x65,0x76,0x87,0x88,0x99,0x42,0x66,0x63,0x54,0x66,0x76,0x77,0x77,0x87,0x77,0x87,0x9a,0xea,0xe9,0xee,0xa8,0xb6,0xee,0x64,0x97,0x6a,0x79,0x97,0xb9,0xae,0xee,0xee,0xee,0x6e,0xbd,0x2b,
0x32,0x43,0x55,0x65,0x65,0x77,0x87,0x78,0x43,0x55,0x53,0x44,0x55,0x55,0x55,0x65,0x66,0x66,0x76,0x6a,0x76,0x88,0x98,0x98,0x75,0xee,0x63,0xe8,0x5e,0x69,0x77,0x89,0x8e,0x99,0xe9,0xdd,0x4d,0xd8,0x1d,
0x31,0x44,0x55,0x76,0x77,0xa8,0x97,0xea,0x42,0x65,0x53,0x54,0x76,0x76,0x76,0x76,0x87,0x88,0x88,0x8a,0xa9,0x9e,0xaa,0xa9,0x75,0xee,0x43,0x66,0x58,0x77,0xa9,0x9e,0x9e,0xe9,0xde,0xdd,0x4d,0xa9,0x18,
0x31,0x54,0x75,0x98,0x89,0xee,0xe9,0xe9,0x43,0x77,0x84,0x27,0x32,0x54,0x65,0x66,0x77,0x78,0xe9,0x58,0x85,0x79,0x97,0xee,0xe8,0xee,0xe7,0xee,0x8e,0x8e,0xee,0xee,0x9e,0xe9,0xee,0xee,0x7e,0xdd,0x3d,
0xa3,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0x9a,0x99,0x99,0x9,0x91,0x33,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0xf9,
};

static U8_WMV gacCodeLengthsIntraLowRate[] = {
3,
0x32,0x44,0x44,0x65,0x65,0x67,0x76,0x87,0x53,0x65,0x74,0x35,0x43,0x55,0x55,0x66,0x66,0x66,0x66,0x66,0x86,0x88,0x8a,0x75,0x64,0x88,0x96,0xdd,0x6d,0x69,0x87,0x67,0x6d,0x96,0xd9,0x9d,0x5d,0x78,0x1d,
0x31,0x44,0x65,0x66,0x87,0x88,0xe8,0xa9,0x42,0x65,0x43,0x53,0x66,0x77,0x76,0x78,0x88,0x88,0xa9,0x8a,0xa8,0x9e,0xee,0xee,0x75,0xee,0x63,0xa7,0x4e,0xa7,0xe9,0xee,0x8e,0xde,0xdd,0xdd,0x4d,0xdd,0x2d,
0x32,0x43,0x65,0x65,0x88,0xe7,0xe8,0xee,0x42,0x66,0x53,0x34,0x43,0x55,0x55,0x76,0x76,0x79,0x98,0x59,0x86,0x78,0x89,0xee,0x86,0xee,0x74,0xdd,0x5d,0x88,0x99,0xdd,0x7d,0xdd,0xd9,0x8d,0x5d,0x87,0x2d,
0x32,0x44,0x55,0x66,0x55,0x66,0x88,0x76,0x54,0x68,0x65,0x26,0x42,0x54,0x55,0x66,0x77,0x77,0x56,0x66,0x75,0xd8,0xdd,0x86,0x76,0xdd,0xd7,0xcc,0x7c,0x5c,0x86,0x65,0x6c,0xc6,0xcc,0xcc,0x7c,0x8c,0x1c,
0x31,0x44,0x55,0x66,0x76,0x88,0x99,0xe9,0x42,0x65,0x53,0x35,0x54,0x55,0x66,0x66,0x77,0x77,0x77,0x69,0x87,0x98,0xb9,0xb9,0x75,0xee,0x85,0xee,0x6e,0x9b,0xe9,0xab,0x7e,0xe8,0xeb,0xee,0x5d,0xab,0x2d,
0x32,0x43,0x54,0x76,0x8a,0x9a,0xea,0xee,0x43,0x65,0x64,0x25,0x43,0x44,0x54,0x65,0x77,0x67,0x87,0x4a,0x76,0x67,0x89,0xe8,0xe6,0xee,0xa6,0xde,0x6d,0x8d,0x99,0xd8,0x7d,0xda,0xdd,0x8d,0x6d,0xd8,0x2d,
0x32,0x43,0x44,0x54,0x46,0xc6,0xc6,0xc6,0x53,0x66,0x64,0x54,0x65,0x65,0xc6,0x66,0xcc,0x6b,0xb6,0x6b,0xbb,0xbb,0xbb,0x54,0x43,0x6b,0xb4,0xbb,0x5b,0x5b,0xbb,0xbb,0x5b,0xbb,0xbb,0xbb,0x4b,0x6b,0x2b,
0x32,0x54,0x75,0x77,0xea,0xee,0xee,0xee,0x53,0x86,0x74,0x17,0x42,0x44,0x55,0x77,0x78,0x76,0xa8,0x4e,0x76,0x78,0x88,0xee,0x97,0xee,0xe7,0xee,0x8e,0x7e,0xe8,0xee,0x8e,0xee,0xee,0x9e,0x6d,0xd8,0xfd,
};

static U8_WMV gacCodeLengthsIntraHighRate[] = {
3,
0x32,0x43,0x65,0x75,0x87,0x89,0x88,0xae,0x43,0x65,0x64,0x24,0x43,0x44,0x54,0x65,0x77,0x77,0x87,0x59,0x76,0x77,0x9a,0xea,0xd6,0xdd,0x95,0xdd,0x6d,0x7d,0xa8,0xa9,0x7d,0xd9,0xdd,0xdd,0x5d,0xa8,0x1d,
0x21,0x43,0x55,0x76,0x77,0x88,0xaa,0xaa,0x42,0x65,0x53,0x73,0x98,0x98,0xb9,0x99,0x99,0xba,0xb9,0xeb,0xee,0xde,0xdd,0xaa,0x97,0xdb,0x53,0x76,0x59,0xa7,0xd9,0xba,0xdd,0xdd,0xdd,0xdd,0x5d,0xaa,0x29,
0x32,0x54,0x76,0x77,0x89,0x99,0x9f,0xf9,0x42,0x75,0x42,0x63,0x88,0x88,0x98,0x99,0x99,0x89,0xa9,0x9f,0x9a,0x9a,0xaf,0xee,0x86,0xee,0x32,0x55,0x47,0xe6,0xee,0xae,0xae,0xaa,0xee,0xee,0x4e,0x7a,0x17,
0x21,0x33,0x44,0x55,0x55,0x66,0x77,0x87,0x53,0x86,0x75,0x56,0x55,0x55,0x66,0x66,0x66,0x66,0x77,0xa8,0xe9,0xee,0xee,0x76,0xb7,0xe8,0x86,0xee,0x7e,0x5a,0x76,0x67,0xa8,0xea,0xee,0xdd,0x7d,0xdd,0x1d,
0x31,0x54,0x65,0x76,0x77,0x88,0x99,0xbd,0x42,0x65,0x53,0x44,0x55,0x65,0x76,0x76,0x77,0x77,0x98,0x69,0x87,0x98,0x8a,0x98,0x76,0xbb,0x53,0x77,0x58,0x87,0x99,0x9a,0x8a,0xa8,0xda,0xad,0x5d,0x88,0x19,
0x21,0x43,0x54,0x65,0x66,0x77,0x87,0x89,0x42,0x76,0x64,0x45,0x65,0x66,0x77,0x76,0x77,0x77,0x87,0xa8,0xbb,0xce,0xee,0x87,0x97,0xc8,0x64,0x88,0x6e,0x7a,0x77,0x78,0xba,0xec,0xee,0xee,0x6e,0xad,0x2a,
0x32,0x43,0x54,0x65,0x77,0x87,0x88,0xba,0x42,0x65,0x53,0x34,0x54,0x65,0x66,0x66,0x76,0x77,0x78,0x69,0x87,0x8a,0xb9,0xe8,0x65,0xee,0x64,0xa8,0x5e,0x78,0x98,0xa9,0x7e,0xe8,0xee,0xdd,0x4d,0x89,0x1d,
0x31,0x54,0x66,0x77,0x88,0x98,0xee,0xee,0x42,0x65,0x53,0x73,0x87,0x89,0x89,0x99,0x9e,0xaa,0x9e,0x8e,0xea,0xae,0xea,0xea,0x96,0xee,0x42,0x66,0x48,0x86,0xea,0xdd,0x8d,0xd8,0xdd,0xdd,0x4d,0x7a,0xf9,
};

// Joint Laplacian coding for DCT DC components
static U8_WMV gacCodeLengthsDCHighRate[]={
3,
0x34,0x44,0x44,0x55,0x77,0xcc,0xcc,0xcc,0x1c,0x21,0x43,0x75,0xc8,0xcc,0xcc,0xcc,0xcc,
0x23,0x32,0x23,0x23,0x33,0x54,0x88,0xcc,0x5c,0x55,0x86,0x76,0xc8,0xcc,0xbb,0xb8,0xbb,
0x23,0x32,0x33,0x33,0x55,0x66,0xbb,0xbb,0x3b,0x32,0x54,0x65,0xb7,0xbb,0xbb,0xbb,0xaa,
0x13,0x22,0x22,0x33,0x55,0x76,0xdd,0xdd,0x8c,0x76,0xc7,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,
0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x6,0x61,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
0x34,0x54,0x55,0x56,0x56,0x67,0xc7,0xcc,0x2c,0x20,0x76,0xc8,0xcc,0xcc,0xcc,0xcc,0xbc,
0x13,0x22,0x33,0x54,0x66,0xd7,0x9d,0xd8,0x3d,0x42,0x75,0xd7,0xdd,0xdd,0xdd,0xdd,0xcd,
0x55,0x65,0x56,0x55,0x76,0x87,0xd9,0xdd,0xd,0x31,0x54,0x76,0xdd,0xdd,0xdd,0xdd,0xcc,
};

static U8_WMV gacCodeLengthsDCLowRate[] = {
3,
0x34,0x43,0x34,0x44,0x66,0xbb,0xbb,0xbb,0x2b,0x21,0x43,0x64,0xb7,0xbb,0xbb,0xbb,0xbb,
0x22,0x32,0x23,0x33,0x65,0xa6,0xaa,0xaa,0x5a,0x43,0x54,0x64,0xa6,0xa6,0xaa,0xaa,0x99,
0x66,0x65,0x65,0x77,0xcc,0xcc,0xcc,0xcc,0xb,0x21,0x54,0xb7,0xbb,0xbb,0xbb,0xbb,0xbb,
0x23,0x32,0x23,0x22,0x44,0xa6,0xaa,0xaa,0x4a,0x56,0x65,0x66,0xa6,0xaa,0xa6,0xaa,0x99,
0x67,0x66,0x78,0xd8,0xdd,0xdd,0xdd,0xcd,0x1c,0x20,0x53,0x86,0xcc,0xcc,0xcc,0xcc,0xcc,
0x66,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x5,0x55,0x55,0x55,
0x34,0x44,0x45,0x55,0x77,0xcc,0xcc,0xcc,0x1c,0x21,0x43,0x74,0xc8,0xcc,0xcc,0xcc,0xcc,
0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x6,0x61,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
};


/**********************************************************************
  setCodes : setting local huffman codes based on QP
**********************************************************************/

static Void_WMV LhdecSetCodes (t_CLocalHuffmanDecoder *pLhdec, I32_WMV inQP)
{
    DEBUG_PROFILE_FRAME_FUNCTION_COUNT(LhdecSetCodes);

    // inter code tables
    if (pLhdec->m_iMode == LH_INTER0 || pLhdec->m_iMode == LH_INTER) {
        pLhdec->opt = (inQP < 13) ? gacCodeLengthsInterHighRate : gacCodeLengthsInterLowRate;
    }
    // intra code tables
    else if (pLhdec->m_iMode == LH_INTRAY0 || pLhdec->m_iMode == LH_INTRAY) {
        pLhdec->opt = (inQP < 13) ? gacCodeLengthsIntraHighRate : gacCodeLengthsIntraLowRate;
    }
    // Orientation tables
    else if (pLhdec->m_iMode == LH_ORIENT) {
        pLhdec->opt = (inQP < 13) ? gacCodeLengthsOrientHighRate : gacCodeLengthsOrientLowRate;
    }
    // MV tables
    else if (pLhdec->m_iMode == LH_MV0 || pLhdec->m_iMode == LH_CBP) {
        if (pLhdec->m_iMode == LH_MV0)
            pLhdec->m_pFine = fineTblMV;
        return;
    }

    // DCT DC code tables
    else if (pLhdec->m_iMode > LH_ORIENT) {  // DCT DC codes
        pLhdec->opt = (inQP < 13) ? gacCodeLengthsDCHighRate : gacCodeLengthsDCLowRate;
    }

    pLhdec->m_iK = 1 << (pLhdec->logK = *pLhdec->opt++);
}

/**********************************************************************
 CLocalHuffmanDecoder : destructor
**********************************************************************/

static Void_WMV  LhdecDestruct (tWMVDecInternalMember *pWMVDec, t_CLocalHuffmanDecoder *pLhdec)
{
    DEBUG_PROFILE_FRAME_FUNCTION_COUNT(LhdecDestruct);

    if ( pLhdec != NULL_WMV ) {
        DEBUG_HEAP_SUB(DHEAP_LOCAL_COUNT,1); // count number of tables actually freed
        Huffman_WMV8_destruct(pWMVDec, pLhdec->m_pHuff);
		if ( pLhdec->m_pHuff != NULL_WMV ){
#ifdef VO_LOG_INFO_MemoryFree
		VOLOGI("\n VO_LOG_INFO m_pHuff :%x",(U32_WMV)pLhdec->m_pHuff );
#endif
            wmvFree ( pWMVDec, pLhdec->m_pHuff );
		}
		if (pLhdec->m_pCodeTable != NULL_WMV ){
#ifdef VO_LOG_INFO_MemoryFree
		VOLOGI("\n VO_LOG_INFO m_pCodeTable :%x",(U32_WMV)pLhdec->m_pCodeTable );
#endif
            wmvFree (pWMVDec, pLhdec->m_pCodeTable);
		}
		if (pLhdec->fineMask != NULL_WMV ){
#ifdef VO_LOG_INFO_MemoryFree
		VOLOGI("\n VO_LOG_INFO fineMask :%x",(U32_WMV)pLhdec->fineMask );
#endif
            wmvFree (pWMVDec, pLhdec->fineMask);
		}

#ifdef VO_LOG_INFO_MemoryFree
		VOLOGI("\n VO_LOG_INFO pLhdec :%x",(U32_WMV)pLhdec );
#endif
        wmvFree (pWMVDec, pLhdec);
    }
}

/**********************************************************************
 CLocalHuffmanDecoder : constructor
**********************************************************************/

static t_CLocalHuffmanDecoder *LhdecConstruct (tWMVDecInternalMember * pWMVDec, I32_WMV iMode,
                                              t_CAltTablesDecoder *pAlt)
{
    I32_WMV j;
#ifdef XDM
	t_CLocalHuffmanDecoder *pLhdec = (t_CLocalHuffmanDecoder *)pWMVDec->m_MemXDM.pPrivateBuff;
	pWMVDec->m_MemXDM.pPrivateBuff += sizeof(t_CLocalHuffmanDecoder);
#else
    t_CLocalHuffmanDecoder *pLhdec = (t_CLocalHuffmanDecoder *) wmvMalloc (pWMVDec, sizeof(t_CLocalHuffmanDecoder), DHEAP_LOCALHUFF);
    if (pLhdec == NULL_WMV)
        return NULL_WMV;
#endif
    memset(pLhdec,0,sizeof(t_CLocalHuffmanDecoder));
    DEBUG_PROFILE_FRAME_FUNCTION_COUNT(LhdecConstruct);

    pLhdec->m_pAltTable  = pAlt;
#ifdef XDM
	pLhdec->m_pHuff = (Huffman_WMV *)pWMVDec->m_MemXDM.pPrivateBuff;
	pWMVDec->m_MemXDM.pPrivateBuff += sizeof(Huffman_WMV);
#else
    pLhdec->m_pHuff = (Huffman_WMV *)wmvMalloc(pWMVDec, sizeof( Huffman_WMV), DHEAP_LOCALHUFF);// Set Huffman object
    if (pLhdec->m_pHuff ==  NULL_WMV) {
        wmvFree(pWMVDec, pLhdec);
        return NULL_WMV;
    }
#endif
    

    Huffman_WMV_construct(pLhdec->m_pHuff );


    pLhdec->m_iMode = iMode;  // no checks
    pLhdec->m_i1shiftMode = 1 << pLhdec->m_iMode;

    if (iMode < LH_ORIENT) {
        pLhdec->m_pFine = fineTbl;
        pLhdec->m_iN = X1+1;
    }
    else if (iMode == LH_ORIENT) {
        pLhdec->m_pFine = aNulls;
        pLhdec->m_iN = 12; /* number of orientations */
    }
    else {
        pLhdec->m_pFine = fineTblJoint;
        pLhdec->m_iN = iLaplacianAlphabet << 1;
    }

    pLhdec->m_pCodeTablePtr = NULL_WMV;  // no table initialized
#ifdef XDM
	pLhdec->m_pCodeTable = (tPackHuffmanCode_WMV *)pWMVDec->m_MemXDM.pPrivateBuff;
	pWMVDec->m_MemXDM.pPrivateBuff += (pLhdec->m_iN + 2) * sizeof (tPackHuffmanCode_WMV);
	pLhdec->fineMask = (I32_WMV *)pWMVDec->m_MemXDM.pPrivateBuff;
	pWMVDec->m_MemXDM.pPrivateBuff += pLhdec->m_iN * sizeof (I32_WMV);
#else
    pLhdec->m_pCodeTable = (tPackHuffmanCode_WMV *)wmvMalloc (pWMVDec, (pLhdec->m_iN + 2) * sizeof (tPackHuffmanCode_WMV), DHEAP_LOCALHUFF);
    pLhdec->fineMask = (I32_WMV *) wmvMalloc (pWMVDec, pLhdec->m_iN * sizeof (I32_WMV), DHEAP_LOCALHUFF);
    if (pLhdec->m_pCodeTable == NULL_WMV || pLhdec->fineMask == NULL_WMV) {
        LhdecDestruct(pWMVDec, pLhdec);
        return NULL_WMV;
    }
#endif


    // reset fineMask
    for (j = 0; j < pLhdec->m_iN; j++)
        pLhdec->fineMask[j] = (1 << pLhdec->m_pFine[j]) - 1;

    // PREfix might complain a warning here for leaking memory.  The corresponding
    // warning for localhuffman_wmv.c in decoder_c\c is marked "suppress".  If this
    // is shown not a problem, programmers on this function later can feel free to
    // remove this comment block.  tcyang, 02/27/2002.
    return pLhdec;
}

/**********************************************************************
 CLocalHuffman::decodeHeader : decode header
**********************************************************************/

static tWMVDecodeStatus LhdecDecodeHeader(tWMVDecInternalMember *pWMVDec, t_CLocalHuffmanDecoder *pLhdec,
                                  CInputBitStream_WMV* pin)
{
    I32_WMV  iCodeIndex = 0;
    VResultCode vr;
    U8_WMV  *pLengths;
    I32_WMV i;
    FUNCTION_PROFILE_DECL_START(fp,DECODEIX8LHHEADER_PROFILE);
    DEBUG_PROFILE_FRAME_FUNCTION_COUNT(LhdecDecodeHeader);
   
    iCodeIndex = BS_getBits(pin, pLhdec->logK);

    pLengths = pLhdec->opt + iCodeIndex * ((pLhdec->m_iN + 1) >> 1);
    if (pLhdec->m_pCodeTablePtr == pLengths) {
        FUNCTION_PROFILE_STOP(&fp);
        return  WMV_Succeeded;
    }
    pLhdec->m_pCodeTablePtr = pLengths;

    for (i = 0; i < pLhdec->m_iN; i++) {
        U8_WMV  c = *pLengths++;
        pLhdec->m_pCodeTable[i + 1].length = (c & 0xf) + 1;
        i++;
        pLhdec->m_pCodeTable[i + 1].length = ((c >> 4) & 0xf) + 1;
    }

    generateHuffman_balanced (pLhdec->m_pCodeTable, pLhdec->m_iN);
    /** reinitialize huffman table **/
    //pLhdec->m_pHuff->init(pLhdec->m_pAltTable->m_uiUserData, pLhdec->m_pCodeTable);

    DEBUG_HEAP_ADD(DHEAP_LOCAL_COUNT,1); // count number of tables actually allocated
    DEBUG_HEAP_ADD(DHEAP_LOCALHUFF,0);  // indicate this huffman table is for localHuffman
    vr = Huffman_WMV8_init (pWMVDec, pLhdec->m_pHuff, pLhdec->m_pAltTable->m_uiUserData, pLhdec->m_pCodeTable, HUFFMAN_DECODE_ROOT_BITS);
    
    FUNCTION_PROFILE_STOP(&fp);
    if (vr != vrNoError) return WMV_BadMemory;

    return  WMV_Succeeded;
}

/**********************************************************************
 CLocalHuffman::if2rll : converts index, fine into run, level, last
**********************************************************************/
static const I8_WMV gOff0[]={16,24, 4,8, 32,16, 4,8,12,16,24, 3,7};
static const I8_WMV gOff1[]={16,20,24,28,32,48, 4,8,16, 4,8,16, 3,7};

static VOINLINE Void_WMV if2rll(I32_WMV iIndex, I32_WMV iFine, U32_WMV* puRun,
                          I32_WMV* piLevel, I32_WMV* pbLast, I32_WMV *pFineMask)
{
    I32_WMV hfine;
    DEBUG_PROFILE_FRAME_FUNCTION_COUNT(if2rll);

    if (iIndex < L0a) {
        if (iIndex < (L0a>>1))  *pbLast=0;
        else {
            *pbLast=1;
            iIndex -= (L0a>>1);
        }
        if (iIndex < 16) {
            *piLevel = 0;
            *puRun = iIndex;
        }
        else if (iIndex < 20) {
            *piLevel = 1;
            *puRun = iIndex-16;
        }
        else if (iIndex < 22) {
            *piLevel = 2;
            *puRun = iIndex-20;
        }
        else {
            *piLevel = 3;
            *puRun = 0;
        }
        return;
    }

    HUFFMANGET_DBG_CACHE(pFineMask,index,4);

    iFine &= pFineMask[iIndex];
    *piLevel = 0;

    if (iIndex < L1a) {
        *pbLast=0;
        if (iIndex <= L0b)
            *puRun = gOff0[iIndex-L0a]+iFine;
        else if (iIndex<=L0d) {
            *piLevel = 1;
            *puRun = gOff0[iIndex-L0a]+iFine;
        }
        else if (iIndex==L0e) {
            *puRun = gOff0[iIndex-L0a]+iFine;
        }
        else if (iIndex==L0f) {
            *piLevel = 1;
            *puRun = gOff0[iIndex-L0a]+iFine;
        }
        else if (iIndex <= L0v) {
            *puRun=0;
            *piLevel = gOff0[iIndex-L0a]+iFine;
        }
        else {
            *puRun=1;
            *piLevel = gOff0[iIndex-L0a]+iFine;
        }
        return;
    }

    else if (iIndex < Q0) {
        *pbLast=1;
        if (iIndex <= L1f)
            *puRun = gOff1[iIndex-L1a]+iFine;
        else if (iIndex <= L1i) {
            *piLevel = 1;
            *puRun = gOff1[iIndex-L1a]+iFine;
        }
        else if (iIndex <= L1x) {
            *puRun=0;
            *piLevel=gOff1[iIndex-L1a]+iFine;
        }
        else {
            *puRun=1;
            *piLevel=gOff1[iIndex-L1a]+iFine;
        }
        return;
    }

    else if (iIndex < X0) {  // funkyQ processing
        I32_WMV  which=iFine&0x3;
        iFine>>=2;
        *pbLast=iIndex-Q0;
        switch (which) {
        case 0:
            *puRun=2;
            *piLevel=2+iFine;
            break;
        case 1:
            *puRun=3+iFine;
            *piLevel=2;
            break;
        case 2:
            *puRun=3+(iFine&1);
            *piLevel=3+(iFine>>1);
            break;
        case 3:
            *puRun=5+(iFine&3);
            *piLevel=3+(iFine>>2);
            break;
        default:;
        }
        return;
    }

    *puRun=0;
    *pbLast = iFine&1;
    hfine = (iFine>>1);

// X0 and X1
    *puRun = hfine&0x3f;
    *piLevel = hfine>>6;
}

/**********************************************************************
 CLocalHuffman::decodeSymbol : decode symbol (run, level, last)
 Return value: 1 : use legacy decoding
               0 : symbol already decoded
**********************************************************************/

I32_WMV LhdecDecodeSymbol (tWMVDecInternalMember *pWMVDec, t_CLocalHuffmanDecoder *pLhdec,
                           CInputBitStream_WMV* pbitstrmIn,
                           U32_WMV* puRun, I32_WMV* piLevel, I32_WMV* pbLast, tWMVDecodeStatus * pstatus)
{
/** if m_iNewFrame is true, decode the header and initialize Huffman **/
    I32_WMV iIndex, iFine;
    DEBUG_PROFILE_FRAME_FUNCTION_COUNT(LhdecDecodeSymbol);

    if ((pLhdec->m_pAltTable->m_iNewFrame & pLhdec->m_i1shiftMode) == 0) {
        *pstatus=LhdecDecodeHeader(pWMVDec, pLhdec, pbitstrmIn);
        if((*pstatus)!=WMV_Succeeded) return 0;
        pLhdec->m_pAltTable->m_iNewFrame |= pLhdec->m_i1shiftMode;
    }

    //I32_WMV  iIndex = pLhdec->m_pHuff->get (pbitstrmIn);
    iIndex = Huffman_WMV_get (pLhdec->m_pHuff, pbitstrmIn);
    iFine = pLhdec->m_pFine[iIndex];
    if (iFine)
        iFine = BS_getBits (pbitstrmIn, iFine);

    if2rll (iIndex, iFine, puRun, piLevel, pbLast, pLhdec->fineMask);
    *piLevel = *piLevel + 1;
    iFine = - (I32_WMV) BS_getBit(pbitstrmIn);
    *piLevel = (*piLevel ^ iFine) - iFine; // conditional change sign

    return 0;
}

/**********************************************************************
  CLocalHuffman::decodeOrient :  decode orientation
**********************************************************************/

I32_WMV LhdecDecodeOrient (tWMVDecInternalMember *pWMVDec, t_CLocalHuffmanDecoder *pLhdec,
                           CInputBitStream_WMV *pbitstrmIn, tWMVDecodeStatus * pstatus)
{
    DEBUG_PROFILE_FRAME_FUNCTION_COUNT(LhdecDecodeOrient);
    // if m_iNewFrame is true, decode header and initialize Huffman
    if ((pLhdec->m_pAltTable->m_iNewFrame & pLhdec->m_i1shiftMode) == 0) {
        *pstatus = LhdecDecodeHeader (pWMVDec, pLhdec, pbitstrmIn);
        if((*pstatus)!=WMV_Succeeded) return 0;
        pLhdec->m_pAltTable->m_iNewFrame |= pLhdec->m_i1shiftMode;
    }
   // return pLhdec->m_pHuff->get(pbitstrmIn);
    return Huffman_WMV_get (pLhdec->m_pHuff, pbitstrmIn);
}

/**********************************************************************
  if2ll : index-fine to level-last
**********************************************************************/

static const U8_WMV gIntervals[]={5,7, 9,13, 17,25, 33,49, 65,97, 129,193};

 void if2ll (I32_WMV index, I32_WMV fine,
                              I32_WMV* plevel, I32_WMV* plast)
{
    DEBUG_PROFILE_FRAME_FUNCTION_COUNT(if2ll);
    *plast=0;
    if (index >= iLaplacianAlphabet) {
        (*plast)++;
        index -= iLaplacianAlphabet;
    }
    if (index >= 5) {
        index = gIntervals[index - 5] + (fine >> 1);  // assumed that fine is masked
    }
    fine = -(fine & 1);
    *plevel = (index ^ fine) - fine;
}

/**********************************************************************
  CLocalHuffman::decodeJoint :  decode DC value (level, last)
**********************************************************************/

I32_WMV LhdecDecodeJoint (tWMVDecInternalMember *pWMVDec, t_CLocalHuffmanDecoder *pLhdec,
                          CInputBitStream_WMV *pbitstrmIn, tWMVDecodeStatus * pstatus)
{
/** if m_iNewFrame is true, decode the header and initialize Huffman **/
    I32_WMV iLevel = 0, iLast = 0, iFine = 0;
	U32_WMV iIndex = 0;
    DEBUG_PROFILE_FRAME_FUNCTION_COUNT(LhdecDecodeJoint);

    if ((pLhdec->m_pAltTable->m_iNewFrame & pLhdec->m_i1shiftMode) == 0) {
        *pstatus = LhdecDecodeHeader (pWMVDec, pLhdec, pbitstrmIn);
        if((*pstatus)!=WMV_Succeeded) return 0;
        pLhdec->m_pAltTable->m_iNewFrame |= pLhdec->m_i1shiftMode;
    }

/** read index **/
    iIndex = Huffman_WMV_get (pLhdec->m_pHuff, pbitstrmIn);

    iFine = pLhdec->m_pFine[iIndex];
    if (iFine)
        iFine = BS_getBits(pbitstrmIn, iFine);
    if2ll(iIndex, iFine, &iLevel, &iLast);

    iLevel += iLevel;
    iLevel += iLast;
    return iLevel;
}

/**********************************************************************
 CAltTablesDecoder : constructor
**********************************************************************/

t_CAltTablesDecoder *t_AltTablesDecoderConstruct (tWMVDecInternalMember *pWMVDec, U32_WMV uiUserData)
{
    I32_WMV i;
#ifdef XDM
	t_CAltTablesDecoder *pAltTab = (t_CAltTablesDecoder *)pWMVDec->m_MemXDM.pPrivateBuff;
	pWMVDec->m_MemXDM.pPrivateBuff += sizeof(t_CAltTablesDecoder);
#else
    t_CAltTablesDecoder *pAltTab = (t_CAltTablesDecoder *)wmvMalloc (pWMVDec, sizeof(t_CAltTablesDecoder), DHEAP_LOCALHUFF);
    DEBUG_PROFILE_FRAME_FUNCTION_COUNT(t_AltTablesDecoderConstruct);
    if (pAltTab == NULL_WMV)
        return NULL_WMV;
#endif
    memset( pAltTab, 0, sizeof(t_CAltTablesDecoder));

    pAltTab->m_bIntraFrame = FALSE_WMV;
    pAltTab->m_uiUserData = uiUserData;
    pAltTab->m_iNewFrame = 0;
    pAltTab->m_bIsFirstRun = TRUE_WMV;
    pAltTab->m_iNContexts = LH_ENUM_SIZE;
    pAltTab->m_iNContexts = LH_INTRAC0 + 1;

    for (i = 0; i < pAltTab->m_iNContexts; i++)
        pAltTab->m_paLH[i]  = LhdecConstruct (pWMVDec, i, pAltTab);
    return pAltTab;
}

/**********************************************************************
 CAltTablesDecoder : destructor
**********************************************************************/

Void_WMV t_AltTablesDecoderDestruct (tWMVDecInternalMember *pWMVDec, t_CAltTablesDecoder *pAltTab)
{
    I32_WMV i;
    DEBUG_PROFILE_FRAME_FUNCTION_COUNT(t_AltTablesDecoderDestruct);
    if (pAltTab != NULL_WMV) {
        for (i = 0; i<pAltTab->m_iNContexts; i++)
            LhdecDestruct (pWMVDec, pAltTab->m_paLH[i]);
        wmvFree (pWMVDec, pAltTab);
    }
}

/**********************************************************************
 CAltTables::setNewFrame
 clears m_iNewFrame parameter, and sets frame-level variables
**********************************************************************/

Void_WMV t_AltTablesSetNewFrame (t_CAltTablesDecoder *pAltTab,
              I32_WMV iQLev, I32_WMV pOrI)
{
    I32_WMV i;
    DEBUG_PROFILE_FRAME_FUNCTION_COUNT(t_AltTablesSetNewFrame);
    pAltTab->m_iNewFrame = 0;
//#ifdef X9
    pAltTab->m_iNewFrame = (1 << LH_CBP);
//#endif // X9
    pAltTab->m_iQLev = iQLev;
    if (pOrI)  {
        pAltTab->m_iNewIntraFrame = 0;
        pAltTab->m_bIntraFrame = TRUE_WMV;
    }
    else
        pAltTab->m_bIntraFrame = FALSE_WMV;

    // Set codes
    for (i = 0; i < pAltTab->m_iNContexts; i++)
        LhdecSetCodes(pAltTab->m_paLH[i], iQLev);
}

Void_WMV t_AltTablesDecodeHeader (t_CAltTablesDecoder *pAltTab, CInputBitStream_WMV *pbsIn)
{
    DEBUG_PROFILE_FRAME_FUNCTION_COUNT(t_AltTablesDecodeHeader);
    pAltTab->m_iNewIntraFrame = 0;
    pAltTab->m_bIntraFrame = TRUE_WMV;
}
//#endif // X9