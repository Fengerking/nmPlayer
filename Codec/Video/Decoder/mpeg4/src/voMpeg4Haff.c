/************************************************************************
*									                                    *
*	VisualOn, Inc. Confidential and Proprietary, 2005		            *
*								 	                                    *
************************************************************************/
#include "voMpeg4DecGlobal.h"
#include "voMpeg4Haff.h"
#include "voMpegReadbits.h"
#include "voMpeg4Dec.h"
#include "voMpeg4Rvlc.h"
#include "voMpeg4Parser.h"
#include "voMpeg4MB.h"

extern VOCONST VO_U8 scanTab[3][64];

VOCONST VO_U16 vld_intra[112+47+120+2+64+16] = {
	//112
	0x7881, 0x7861, 0x70c1, 0x78a1, 0x70e1, 0x7042, 0x7023, 0x7009, 
	0x6802, 0x6802, 0x60a1, 0x60a1, 0x6841, 0x6841, 0x6821, 0x6821, 
	0x6081, 0x6081, 0x6061, 0x6061, 0x6008, 0x6008, 0x6007, 0x6007, 
	0x6022, 0x6022, 0x6006, 0x6006, 0x5041, 0x5041, 0x5041, 0x5041, 
	0x5005, 0x5005, 0x5005, 0x5005, 0x5004, 0x5004, 0x5004, 0x5004, 
	0x4801, 0x4801, 0x4801, 0x4801, 0x4801, 0x4801, 0x4801, 0x4801, 
	0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
	0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
	0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
	0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
	0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
	0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
	0x4021, 0x4021, 0x4021, 0x4021, 0x4021, 0x4021, 0x4021, 0x4021, 
	0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 

	//47
	0x99c1, 0x99a1, 0x9981, 0x9961, 0x9941, 0x9822, 0x9804, 0x9181, 
	0x9161, 0x90e2, 0x90c2, 0x90a2, 0x9063, 0x9043, 0x9026, 0x9025, 
	0x9010, 0x9082, 0x900f, 0x900e, 0x900d, 0x8901, 0x8901, 0x88e1, 
	0x88e1, 0x88c1, 0x88c1, 0x8803, 0x8803, 0x8141, 0x8141, 0x8121, 
	0x8121, 0x8101, 0x8101, 0x8921, 0x8921, 0x8062, 0x8062, 0x8024, 
	0x8024, 0x800c, 0x800c, 0x800b, 0x800b, 0x800a, 0x800a, 

	//120
	0xb807, 0xb807, 0xb806, 0xb806, 0xb016, 0xb016, 0xb015, 0xb015, 
	0xa842, 0xa842, 0xa842, 0xa842, 0xa823, 0xa823, 0xa823, 0xa823, 
	0xa805, 0xa805, 0xa805, 0xa805, 0xa1a1, 0xa1a1, 0xa1a1, 0xa1a1, 
	0xa0a3, 0xa0a3, 0xa0a3, 0xa0a3, 0xa102, 0xa102, 0xa102, 0xa102, 
	0xa083, 0xa083, 0xa083, 0xa083, 0xa064, 0xa064, 0xa064, 0xa064, 
	0xa044, 0xa044, 0xa044, 0xa044, 0xa027, 0xa027, 0xa027, 0xa027, 
	0xa014, 0xa014, 0xa014, 0xa014, 0xa013, 0xa013, 0xa013, 0xa013, 
	0xb017, 0xb017, 0xb018, 0xb018, 0xb028, 0xb028, 0xb122, 0xb122, 
	0xb862, 0xb862, 0xb882, 0xb882, 0xb9e1, 0xb9e1, 0xba01, 0xba01, 
	0xc019, 0xc01a, 0xc01b, 0xc029, 0xc0c3, 0xc02a, 0xc045, 0xc0e3, 
	0xc1c1, 0xc808, 0xc8a2, 0xc8c2, 0xca21, 0xca41, 0xca61, 0xca81, 
	0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 
	0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 
	0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 
	0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff,

	//2
	0xa012, 0xa011, 

	//64
	0x0a1b, 0x0405, 0x0303, 0x0303, 0x0202, 0x0101, 0x0101, 0x0001,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0308, 0x0202, 0x0202, 0x0102, 0x0101, 0x0101, 0x0101, 0x0101,
	0x0101, 0x0101, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

	//16
	0x0f02, 0x080a, 0x0304, 0x0202, 0x0202, 0x0102, 0x0101, 0x0101,
	0x1501, 0x0207, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101
};


VOCONST VO_U16 vld_intra_aic[112+47+120+2+64+16] = {
	//112
	0x7803, 0x7881, 0x78c1, 0x78a1, 0x7023, 0x7042, 0x7009, 0x70a1, 
	0x6802, 0x6802, 0x6861, 0x6861, 0x6841, 0x6841, 0x6821, 0x6821, 
	0x6006, 0x6006, 0x6007, 0x6007, 0x6008, 0x6008, 0x6081, 0x6081, 
	0x6022, 0x6022, 0x6061, 0x6061, 0x5041, 0x5041, 0x5041, 0x5041, 
	0x5004, 0x5004, 0x5004, 0x5004, 0x5005, 0x5005, 0x5005, 0x5005, 
	0x4801, 0x4801, 0x4801, 0x4801, 0x4801, 0x4801, 0x4801, 0x4801, 
	0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
	0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
	0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
	0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
	0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
	0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 0x3002, 
	0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 0x4003, 
	0x4021, 0x4021, 0x4021, 0x4021, 0x4021, 0x4021, 0x4021, 0x4021, 

	//47
	0x9805, 0x9806, 0x9822, 0x9842, 0x99e1, 0x9a01, 0x9a41, 0x9a21, 
	0x99c1, 0x900d, 0x900e, 0x900f, 0x9010, 0x9011, 0x9012, 0x900b, 
	0x900c, 0x90a2, 0x9082, 0x9121, 0x9101, 0x8804, 0x8804, 0x88e1, 
	0x88e1, 0x8901, 0x8901, 0x89a1, 0x89a1, 0x8981, 0x8981, 0x8961, 
	0x8961, 0x8941, 0x8941, 0x8921, 0x8921, 0x800a, 0x800a, 0x80c1, 
	0x80c1, 0x8062, 0x8062, 0x8024, 0x8024, 0x80e1, 0x80e1, 

	//120
	0xba61, 0xba61, 0xba81, 0xba81, 0xb122, 0xb122, 0xb083, 0xb083, 
	0xa807, 0xa807, 0xa807, 0xa807, 0xa823, 0xa823, 0xa823, 0xa823, 
	0xa862, 0xa862, 0xa862, 0xa862, 0xa882, 0xa882, 0xa882, 0xa882, 
	0xa181, 0xa181, 0xa181, 0xa181, 0xa044, 0xa044, 0xa044, 0xa044, 
	0xa102, 0xa102, 0xa102, 0xa102, 0xa0e2, 0xa0e2, 0xa0e2, 0xa0e2, 
	0xa0c2, 0xa0c2, 0xa0c2, 0xa0c2, 0xa063, 0xa063, 0xa063, 0xa063, 
	0xa043, 0xa043, 0xa043, 0xa043, 0xa025, 0xa025, 0xa025, 0xa025, 
	0xb1a1, 0xb1a1, 0xb026, 0xb026, 0xb014, 0xb014, 0xb013, 0xb013, 
	0xb843, 0xb843, 0xb824, 0xb824, 0xb809, 0xb809, 0xb808, 0xb808, 
	0xc027, 0xc064, 0xc0a3, 0xc019, 0xc018, 0xc017, 0xc016, 0xc015, 
	0xcaa1, 0xcac1, 0xcae1, 0xc8e2, 0xc8c2, 0xc8a2, 0xc863, 0xc80a, 
	0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 
	0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 
	0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 
	0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 

	//2
	0xa161, 0xa141,

	//64
	0x0a1b, 0x0405, 0x0303, 0x0303, 0x0202, 0x0101, 0x0101, 0x0001,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0308, 0x0202, 0x0202, 0x0102, 0x0101, 0x0101, 0x0101, 0x0101,
	0x0101, 0x0101, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

	//16
	0x0f02, 0x080a, 0x0304, 0x0202, 0x0202, 0x0102, 0x0101, 0x0101,
	0x1501, 0x0207, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101
};


VOCONST VO_U16 vld_inter[112+47+120+2+64+16] = {
	//112
	0x7901, 0x78e1, 0x78c1, 0x78a1, 0x7181, 0x7161, 0x7141, 0x7004, 
	0x6881, 0x6881, 0x6861, 0x6861, 0x6841, 0x6841, 0x6821, 0x6821, 
	0x6121, 0x6121, 0x6101, 0x6101, 0x60e1, 0x60e1, 0x60c1, 0x60c1, 
	0x6022, 0x6022, 0x6003, 0x6003, 0x50a1, 0x50a1, 0x50a1, 0x50a1, 
	0x5081, 0x5081, 0x5081, 0x5081, 0x5061, 0x5061, 0x5061, 0x5061, 
	0x4801, 0x4801, 0x4801, 0x4801, 0x4801, 0x4801, 0x4801, 0x4801, 
	0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
	0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
	0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
	0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 0x2001, 
	0x3021, 0x3021, 0x3021, 0x3021, 0x3021, 0x3021, 0x3021, 0x3021, 
	0x3021, 0x3021, 0x3021, 0x3021, 0x3021, 0x3021, 0x3021, 0x3021, 
	0x4041, 0x4041, 0x4041, 0x4041, 0x4041, 0x4041, 0x4041, 0x4041, 
	0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 0x4002, 

	//47
	0x9b01, 0x9ae1, 0x9ac1, 0x9aa1, 0x9a81, 0x9a61, 0x9a41, 0x9a21, 
	0x9802, 0x92c1, 0x92a1, 0x9281, 0x9261, 0x9241, 0x9221, 0x9201, 
	0x91e1, 0x9082, 0x9062, 0x9007, 0x9006, 0x8a01, 0x8a01, 0x89e1, 
	0x89e1, 0x89c1, 0x89c1, 0x89a1, 0x89a1, 0x8981, 0x8981, 0x8961, 
	0x8961, 0x8941, 0x8941, 0x8921, 0x8921, 0x81c1, 0x81c1, 0x81a1, 
	0x81a1, 0x8042, 0x8042, 0x8023, 0x8023, 0x8005, 0x8005, 

	//120
	0xb822, 0xb822, 0xb803, 0xb803, 0xb00b, 0xb00b, 0xb00a, 0xb00a, 
	0xab81, 0xab81, 0xab81, 0xab81, 0xab61, 0xab61, 0xab61, 0xab61, 
	0xab41, 0xab41, 0xab41, 0xab41, 0xab21, 0xab21, 0xab21, 0xab21, 
	0xa122, 0xa122, 0xa122, 0xa122, 0xa102, 0xa102, 0xa102, 0xa102, 
	0xa0e2, 0xa0e2, 0xa0e2, 0xa0e2, 0xa0c2, 0xa0c2, 0xa0c2, 0xa0c2, 
	0xa0a2, 0xa0a2, 0xa0a2, 0xa0a2, 0xa063, 0xa063, 0xa063, 0xa063, 
	0xa043, 0xa043, 0xa043, 0xa043, 0xa024, 0xa024, 0xa024, 0xa024, 
	0xb00c, 0xb00c, 0xb025, 0xb025, 0xb2e1, 0xb2e1, 0xb301, 0xb301, 
	0xbba1, 0xbba1, 0xbbc1, 0xbbc1, 0xbbe1, 0xbbe1, 0xbc01, 0xbc01, 
	0xc026, 0xc044, 0xc083, 0xc0a3, 0xc0c3, 0xc142, 0xc321, 0xc341, 
	0xcc21, 0xcc41, 0xcc61, 0xcc81, 0xcca1, 0xccc1, 0xcce1, 0xcd01, 
	0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 
	0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 
	0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 
	0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 0x7fff, 

	//2
	0xa009,	0xa008, 

	//64
	0x060c, 0x0304, 0x0303, 0x0203, 0x0202, 0x0102, 0x0101, 0x0101,
	0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0001, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0203, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101,
	0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101,
	0x0101, 0x0101, 0x0101, 0x0101, 0x0001, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

	//16
	0x1b02, 0x070b, 0x0203, 0x0102, 0x0101, 0x0101, 0x0101, 0x0101,
	0x2901, 0x0102, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101
};

#define MPEG4_VLD\
	code = SHOW_BIT_POS(cache_a,12);				\
	if(code >> 9){\
		code = (code >> 5) - 16 + NEWT1;\
	}else if (code >135){\
		code = (code >> 3) - 17 + NEWT2;\
	}else if(code < 128){\
		if (!(code >> 3)){\
			return len;			\
		}\
		code = code - 8 + NEWT3;\
	}else{\
		code = ((code>>2)&1) + NEWT4;\
	}\
	code = table[code];							\
	FLUSH_BIT_POS(cache_a, cache_b, bitpos,code >> 12);



#define H263_DQUANT									\
	level *= q_scale;								\
	level += q_add;									\
	if (GET_BITS_1_POS(cache_a, cache_b, bitpos))	\
		level = -level;



#define ZIGZAG_WRITE	block[scan[len & 63]] = (idct_t)level;							

#define NEWT1           0
#define NEWT2			(112)
#define NEWT3           (112+47)
#define NEWT4           (112+47+88+32)
#define NEWT5           (112+47+88+32+2)

#define NEWTABLE_LMAX		112+49+120
#define NEWTABLE_RMAX		112+49+120+64



VO_S32 Mpeg4GetBlockVld(VO_MPEG4_DEC* pDec, const VO_U16 *table, const VO_U8 *scan, VO_S32 len, idct_t* block, VO_S32 mb_type) 
{
	VO_S32 q_scale = (pDec->nQuant) << 1;
	VO_S32 q_add = (pDec->nQuant-1)|1;
	VO_S32 code, level;

	BEGIN_BITS_POS(pDec);

	do
	{ 	
		CACHE_CHECK(pDec, cache_a, cache_b, bitpos);
		MPEG4_VLD;
		level = code & 0x1F; //level==31 => escape
		if (level != 31) {
			len += ((code >> 5) & 127); // add last and run
		}else{//escape
			CACHE_CHECK(pDec, cache_a, cache_b, bitpos);
			if (!GET_BITS_1_POS(cache_a, cache_b, bitpos)){ // escape 1
				MPEG4_VLD;
				level = code & 31;
				code >>= 5;
				code &= 127;
				len   += code; // last|run
				level += ((VO_U8*)(table+NEWTABLE_LMAX))[code]; // table_lmax[last][run]
			}else if (!GET_BITS_1_POS(cache_a, cache_b, bitpos)) { // escape 2
				MPEG4_VLD;
				len += (code >> 5) & 127;
				code &= 31;
				level = code;
				if (code > 11) code = 11;
				if (len >= 64) code += 16; // add (last bit << 4)
				len += ((VO_U8*)(table+NEWTABLE_RMAX))[code]; // table_rmax[last][min(11,level)]
			}else { // escape 3  
				code = SHOW_BIT_POS(cache_a,20);
				FLUSH_BIT_POS(cache_a, cache_b, bitpos, 21);
				level = (code << 20) >> 20; //sign extend the lower 12 nBits
				level *= q_scale;
				len   += code >> 13;  // last|run
				if (level > 0)
					level += q_add;
				else
					level -= q_add;
				ZIGZAG_WRITE;
				continue;
			}
		}
		H263_DQUANT
			ZIGZAG_WRITE;
	}while(++len < 64);

	END_BITS_POS(pDec);						

	return len - 64;	
}

VO_S32 Mpeg4GetBlockRvld( VO_MPEG4_DEC* pDec, const VO_U16 *table, const VO_U8 *scan, VO_S32 len, idct_t* block, VO_S32 mb_type) 
{
	RL_VLC_ELEM * rl_vlc;
	VO_S32 last, run;
	VO_S32 q_scale = (pDec->nQuant) << 1;
	VO_S32 q_add = (pDec->nQuant-1)|1;
	BEGIN_BITS_POS(pDec);
	len--;

	if(mb_type){
		rl_vlc = (RL_VLC_ELEM *)rvld_intra;
	}else{  
		rl_vlc = (RL_VLC_ELEM *)rvld_inter; 
	}

	while(1) // event vld
	{
		VO_S32 code,level;
		CACHE_CHECK(pDec, cache_a, cache_b, bitpos);

		{
			VO_S32 index, nb_bits;

			index = SHOW_BIT_POS(cache_a, RVLC_BITS);
			level = rl_vlc[index].level;
			code     = rl_vlc[index].len;

			if(2 > 1 && code < 0){
				FLUSH_BIT_POS(cache_a, cache_b, bitpos, RVLC_BITS);

				nb_bits = -code;

				index= SHOW_BIT_POS(cache_a, nb_bits) + level;
				level = rl_vlc[index].level;
				code     = rl_vlc[index].len;
			}
			run= rl_vlc[index].run;
			FLUSH_BIT_POS(cache_a, cache_b, bitpos, code);
		}

		if (level) {
			len += run; // last|run
			H263_DQUANT									
		} else {

			if(SHOW_BIT_POS(cache_a, 1)==0){
				break;
			}; 
			FLUSH_BIT_POS(cache_a, cache_b, bitpos, 1);

			last=  GET_BITS_1_POS(cache_a, cache_b, bitpos); 

			run=   SHOW_BIT_POS(cache_a, 6);
			FLUSH_BIT_POS(cache_a, cache_b, bitpos, 6);

			CACHE_CHECK(pDec, cache_a, cache_b, bitpos);
			if(GET_BITS_1_POS(cache_a, cache_b, bitpos)==0){
				break;
			}; 


			level= SHOW_BIT_POS(cache_a, 11); 
			FLUSH_BIT_POS(cache_a, cache_b, bitpos, 11);

			CACHE_CHECK(pDec, cache_a, cache_b, bitpos);
			if(SHOW_BIT_POS(cache_a, 5)!=0x10){
				break;
			}; 
			FLUSH_BIT_POS(cache_a, cache_b, bitpos, 5);

			CACHE_CHECK(pDec, cache_a, cache_b, bitpos);

			H263_DQUANT

				len += run + 1;
			if(last) 
				len+=192;

		}

		if (len > 62){
			len-= 192;				
			block[scan[len]] = (idct_t)level;
			END_BITS_POS(pDec);
			return ++len;
		}
		block[scan[len]] = (idct_t)level;
	}

	END_BITS_POS(pDec);
	return ++len;
// 	return VO_ERR_NONE;
}


VO_S32 MpegGetBlockVld( VO_MPEG4_DEC* pDec, const VO_U16 *table, const VO_U8 *scan, VO_S32 len, idct_t* block , VO_S32 mb_type) 
{
	VO_S32 q_add = 0;
// 	VO_U32 sum = 0;
	VO_S32 q_scale = pDec->nQuant << 1;
	VO_U8* matrix = pDec->quant[0];
	BEGIN_BITS_POS(pDec);

	if (table == vld_inter)
	{
		q_add = pDec->nQuant;
		matrix += 8*8;
	}

	do 
	{
		VO_S32 code,level;

		CACHE_CHECK(pDec, cache_a, cache_b, bitpos);
		MPEG4_VLD;
		level = code & 0x1F; //level==31 => escape
		if (level != 31) {
			code = ((code >> 5) & 127);
			len +=  code;	// add last and run
		}else{//escape
			CACHE_CHECK(pDec, cache_a, cache_b, bitpos);
			if (!GET_BITS_1_POS(cache_a, cache_b, bitpos)){ // escape 1
				MPEG4_VLD;
				level = code & 31;
				code >>= 5;
				code &= 127;
				len   += code; // last|run
				level += ((VO_U8*)(table+NEWTABLE_LMAX))[code]; // table_lmax[last][run]
			}else if (!GET_BITS_1_POS(cache_a, cache_b, bitpos)) { // escape 2
				MPEG4_VLD;
				len += (code >> 5) & 127;
				code &= 31;
				level = code;
				if (code > 11) code = 11;
				if (len >= 64) code += 16; // add (last bit << 4)
				len += ((VO_U8*)(table+NEWTABLE_RMAX))[code]; // table_rmax[last][min(11,level)]
			}else { // escape 3  
				code = SHOW_BIT_POS(cache_a,20);
				FLUSH_BIT_POS(cache_a, cache_b, bitpos,21);
				level = (code << 20) >> 20; //sign extend the lower 12 nBits
				len   += code >> 13;  // last|run
				code = scan[len & 63];

				if (table == vld_inter || ((code>>3) && (code << 29)) || code == 0)	//left & top will do dequant later(in ac_recon) ---- by harry, 2011.11.8
				{
					int sgn = 1;
					level *= q_scale;
					if (level < 0)
					{
						sgn = -1;
						level = - level;
					}

					level += q_add;
					level *= matrix[code];
					level >>= 4;
					level *= sgn;
// 					sum ^= level;
				}


				ZIGZAG_WRITE;
				continue;
			}
		}

		code = scan[len & 63];
		if (table == vld_inter || ((code>>3) && (code << 29)) || code == 0)	//left & top will do dequant later(in ac_recon) ---- by harry, 2011.11.8
		{
			level *= q_scale;
			level += q_add;
			level *= matrix[code];
			level >>= 4;
// 			sum ^= level;
		}

		if (GET_BITS_1_POS(cache_a, cache_b, bitpos)) 
			level = -level;

		ZIGZAG_WRITE

	} while (++len < 64);

	END_BITS_POS(pDec);

// 	if (table == vld_inter && !(sum&1))	//mismatch control, added by Harry, 2011.11.17
// 	{
// 		block[63] ^= 1;
// 		if (block[63])
// 		{
// 			return 64;
// 		}
// 	}
	return len - 64;
}


VO_S32 H263GetBlockVld( VO_MPEG4_DEC* pDec, const VO_U16 *table, const VO_U8 *scan, VO_S32 len, idct_t* block , VO_S32 nQuant) 
{
	VO_U32 nCodecId = pDec->nCodecId;
	VO_S32 q_scale = nQuant << 1;
	VO_S32 q_add = nQuant;

	BEGIN_BITS_POS(pDec);

	if(pDec->aic)
		q_add = 0;


	do{ 

		VO_S32 code,level;
		CACHE_CHECK(pDec, cache_a, cache_b, bitpos);
		MPEG4_VLD;
		level = code & 31; // 0x7FFF ESCAPE -> level = 31

		if (level != 31) {
			code >>= 5;
			code &= 127;
			len += code; // last|run
			H263_DQUANT
				ZIGZAG_WRITE
		} else {
			// this value is escaped
			CACHE_CHECK(pDec, cache_a, cache_b, bitpos);

			if((nCodecId&CODECID_MASK) == S263_ID){//TBD S263 version
				if((nCodecId&VERSION_MASK) == VERSION_0){
					code = SHOW_BIT_POS(cache_a,15);
					FLUSH_BIT_POS(cache_a, cache_b, bitpos,15);
					level = ((code << 24) >>24);
					len += (code >> 8);  // last|run
				}else{
					code = SHOW_BIT_POS(cache_a,8);
					FLUSH_BIT_POS(cache_a, cache_b, bitpos,8);
					if(code>>7){
						level = SHOW_BIT_POS(cache_a, 11);
						FLUSH_BIT_POS(cache_a, cache_b, bitpos,11);
						level = (level << 21) >> 21;
					} else {
						level = SHOW_BIT_POS(cache_a, 7);
						FLUSH_BIT_POS(cache_a, cache_b, bitpos,7);
						level = (level << 25) >> 25;
					}
					len   += code&0x7f;  // last|run
				}
			}else{
				code = SHOW_BIT_POS(cache_a,15);
				FLUSH_BIT_POS(cache_a, cache_b, bitpos,15);
				level = (code << 24) >> 24; //sign extend the lower 8 nBits
				if (level == -128)
				{
					level = SHOW_BIT_POS(cache_a,5);
					FLUSH_BIT_POS(cache_a, cache_b, bitpos,5);
					CACHE_CHECK(pDec, cache_a, cache_b, bitpos);
					level |= SHOW_BIT_POS(cache_a,6) << 5;
					FLUSH_BIT_POS(cache_a, cache_b, bitpos,6);
					level = (level << 21) >> 21;
				}
				len   += code >> 8;  // last|run

			}
			level *= q_scale;

			if (level > 0)
				level += q_add;
			else
				level -= q_add;

			ZIGZAG_WRITE;
		}
	} while (++len < 64);

	END_BITS_POS(pDec);

	return len - 64;
}


