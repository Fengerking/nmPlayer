#include <stdio.h>
#include <stdlib.h>
#include "string.h"
#include "voVideoParser.h"

#define IN_BUFF_LEN 1024*1024
const unsigned char PARSER_BIG_LEN_TAB[256]=
{
        0x00,0x00,0x01,0x01,0x02,0x02,0x02,0x02,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
        0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
        0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
        0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
        0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
        0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
        0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
        0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07
};
const unsigned char PARSER_UE_VAL[512]=
{
 0x1F,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,
 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09,0x0A,0x0A,0x0A,0x0A,0x0B,0x0B,0x0B,0x0B,0x0C,0x0C,0x0C,0x0C,0x0D,0x0D,0x0D,0x0D,0x0E,0x0E,0x0E,0x0E,
 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static signed long parser_big_len(unsigned long val)
{
	int len = 0;
	if (val & 0xffff0000) {
		val >>= 16;
		len += 16;
	}
	if (val & 0xff00) {
		val >>= 8;
		len += 8;
	}
	len += PARSER_BIG_LEN_TAB[val];

	return len;
}

#define XRAW_IS_ANNEXB(p) ( !(*((p)+0)) && !(*((p)+1)) && (*((p)+2)==1))
#define XRAW_IS_ANNEXB2(p) ( !(*((p)+0)) && !(*((p)+1)) && !(*((p)+2))&& (*((p)+3)==1))
static char* GetNextFrame_test(char* currPos,int size)
{
	char* endPos = currPos+size-4;
	char* p = currPos;  
	unsigned char * tmp_ptr;
	unsigned int bFind = 0;
	unsigned int value;

	do 
	{
		for (; p < endPos; p++)
		{
			if (XRAW_IS_ANNEXB(p))
			{
				tmp_ptr = (unsigned char *)(p + 3);
				break;
			}
			if (XRAW_IS_ANNEXB2(p))
			{
				tmp_ptr = (unsigned char *)(p + 4);
				break;
			}
		}
		if(p>=endPos || tmp_ptr>=endPos)	//need 5 bytes to parse
			return NULL;
		value = (*tmp_ptr++)&0x1F;
		if (value == 1 || value == 5)	//slice or IDR
		{
			value = (((unsigned int)(*tmp_ptr))<<24) | ((unsigned int)(*(tmp_ptr+1))<<16) | ((unsigned int)(*(tmp_ptr+2))<<8) | ((unsigned int)*(tmp_ptr+3));
			if(value >=(1<<27))
			{
				value >>= 32-9;
				value = PARSER_UE_VAL[value];
			}
			else
			{
				value >>= 2*parser_big_len(value)-31;
				value--;
			}
			if (value == 0)	//start_mb_nr = 0, find a new pic
			{
				if (bFind)
				{
					break;
				}
				else
				{
					bFind = 1;
				}
			}
		}
		else if (bFind)
		{
			break;
		}
		p+=3;
	} while (1);
	return p;

}

int H264_test()
{
	FILE *inFile;
	VO_U8 *inputBuf;
	VO_U8 *nextFrame,*currFrame;
	VO_S32 leftSize=IN_BUFF_LEN;
	VO_S32 inSize = 0;
	VO_S32 ret = 0;
	VO_HANDLE hCodec;
	VO_VIDEO_PARSERAPI voVideoParser;
	VO_S32 testcount = 0;
	VO_CODECBUFFER pInData;
	char infilename[255] = "D:\\Numem\\466.h264";

	VO_U32 nVersion=0,nProfile =0,nRatio=0;
	VO_U32 nFrameType = 0;
	VO_U32 nWidth=0,nHeight =0;
	VO_U32 isInterlace =0;
	VO_U32 IsRefFrame =0;
	VO_U32 IsIDRFrame = 0;
	VO_U32 DPB_size = 0;
	VO_U32 ref_number = 0;
	VO_S3D_Params S3D_Param;
	VO_H264_USERDATA_Params User_data;
	VO_PARSER_ASPECTRATIO aspetinfo;
    parser_out_sps_t sps;
	VO_PARSER_SEI_FLAGS sei_flags = {0};
	VO_PARSER_SEI_INFO sei_info;

	inFile= fopen (infilename, "rb");
	if (!inFile)
	{
		printf("\nError: cannot open input H.264 file!");
		exit(0);
	}
	else
		printf("\ninfile:%s\n",infilename);

	ret = voGetVideoParserAPI(&voVideoParser,VO_VIDEO_CodingH264);
	if(ret != VO_ERR_NONE)
		goto H264END;

	ret = voVideoParser.Init(&hCodec);
	if(ret != VO_ERR_NONE)
		goto H264UNINIT;

	inputBuf = (char *)calloc(IN_BUFF_LEN ,1);   //malloc input buffer
	nextFrame = currFrame = inputBuf;
    
	leftSize = fread(currFrame,1,IN_BUFF_LEN,inFile);
	//leftSize = fread(currFrame,1,IN_BUFF_LEN,inFile);
	//currFrame = GetNextFrame_test(currFrame-3,leftSize); //get first nalu head
	while(testcount < 1&&leftSize>4)
	{
		//find next nalu head
		pInData.Buffer = (VO_PBYTE)nextFrame;
		do 
		{
		  nextFrame = GetNextFrame_test(nextFrame,leftSize);
		  if(nextFrame)
	      {
		    inSize = nextFrame-pInData.Buffer;
     	    break;
	      }
		  else
	      {
		    if(leftSize>2*1024*1024)
		    {
		      printf("\nthe next frame is too big to handle,exit\n");
		      exit(0);
		    }
		    if(feof(inFile))//last nalu
		    {
		      inSize=leftSize;
// printf("find last nalu, frame %d, size %d\r\n", iFramesDecoded, inSize);
		      break;
		    }
		    else  //need to fill inputBuf
		    {
		      int readSize;
		      memmove(inputBuf,pInData.Buffer,leftSize);
		      pInData.Buffer = nextFrame =inputBuf;
		      readSize=fread(inputBuf+leftSize,1,IN_BUFF_LEN-leftSize,inFile);
		      leftSize+=readSize;
		    }
	      }
		} while(1);
		pInData.Buffer = (VO_PBYTE)currFrame;
		pInData.Length = inSize;
		//sei_flags.flag0 = 0;
		//sei_flags.flag0 |= VO_SEI_PIC_TIMING;
		//pInData.UserData = &sei_flags;
		ret = voVideoParser.Process(hCodec,&pInData);
		ret = voVideoParser.GetParam(hCodec, VO_PID_VIDEOPARSER_SPS, &sps);
		ret = voVideoParser.GetParam(hCodec, VO_PID_VIDEOPARSER_SEI_INFO, &sei_info);
		leftSize-=inSize;
		currFrame=nextFrame;
		testcount++;
	}
    if(sei_info.buffercount)
	{
	  int i=0;
	  unsigned char *buffer = sei_info.buffer;
	  for(i=0;i<sei_info.buffercount;i++)
	  {
	    if(!sei_info.data[i].flag_group&&sei_info.data[i].flag&VO_SEI_PIC_TIMING)
	    {
		  VO_SEI_PIC_TIMING_STRUCT *pic_time = (VO_SEI_PIC_TIMING_STRUCT *)(buffer+sei_info.data[i].buffer_lenth);
		  buffer+=sei_info.data[i].buffer_lenth+sei_info.data[i].has_struct;
		}
		else if(!sei_info.data[i].flag_group&&sei_info.data[i].flag&VO_SEI_USER_DATA_REGISTERED_ITU_T_T35)
		{
		  buffer+=sei_info.data[i].buffer_lenth+sei_info.data[i].has_struct;
		}
		else
		  buffer+=sei_info.data[i].buffer_lenth+sei_info.data[i].has_struct;
	  }
	}
	/*pInData.Buffer = (VO_PBYTE)currFrame;
	pInData.Length = IN_BUFF_LEN;//leftSize;//inSize;
	ret = voVideoParser.Process(hCodec,&pInData);
	ret = voVideoParser.GetParam(hCodec, VO_PID_VIDEOPARSER_RATIO, &aspetinfo);
	ret = voVideoParser.GetParam(hCodec, VO_PID_VIDEOPARSER_PROFILE, &nProfile);
	ret = voVideoParser.GetParam(hCodec, VO_PID_VIDEOPARSER_FRAMETYPE, &nFrameType);
	ret = voVideoParser.GetParam(hCodec, VO_PID_VIDEOPARSER_WIDTH, &nWidth);
	ret = voVideoParser.GetParam(hCodec, VO_PID_VIDEOPARSER_HEIGHT, &nHeight);
	ret = voVideoParser.GetParam(hCodec, VO_PID_VIDEOPARSER_ISIDRFRAME, &IsIDRFrame);
	ret = voVideoParser.GetParam(hCodec, VO_PID_VIDEOPARSER_INTERLANCE, &isInterlace);
	ret = voVideoParser.GetParam(hCodec, VO_PID_VIDEOPARSER_REFFRAME, &IsRefFrame);
	ret = voVideoParser.GetParam(hCodec, VO_PID_VIDEOPARSER_S3D, &S3D_Param);
	ret = voVideoParser.GetParam(hCodec, VO_PID_VIDEOPARSER_USERDATA, &User_data);
	ret = voVideoParser.GetParam(hCodec, VO_PID_VIDEOPARSER_DPB_SIZE, &DPB_size);
	ret = voVideoParser.GetParam(hCodec, VO_PID_VIDEOPARSER_REFNUM, &ref_number);*/

H264UNINIT:
	ret = voVideoParser.Uninit(hCodec);
H264END:
    return 0;	
}
