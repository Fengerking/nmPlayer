#include "global.h"
#include "cabac.h"
#include "memalloc.h"
//#include "elements.h"
#include "image.h"
// #include "biaridecod.h"
#include "mb_access.h"
#include "ifunctions.h"

#if TRACE
int symbolCount = 0;
#endif
#define VO_CABAC_BITS 16
#define VO_CABAC_MASK ((1<<VO_CABAC_BITS)-1)


static const VO_U8 vo_h264_mlps_state[4*64]=
{
      127,126, 77, 76,
      77, 76, 75, 74,
      75, 74, 75, 74,
      73, 72, 73, 72,
      73, 72, 71, 70,
      71, 70, 71, 70,
      69, 68, 69, 68,
      67, 66, 67, 66,
      67, 66, 65, 64,
      65, 64, 63, 62,
      61, 60, 61, 60,
      61, 60, 59, 58,
      59, 58, 57, 56,
      55, 54, 55, 54,
      53, 52, 53, 52,
      51, 50, 49, 48,
      49, 48, 47, 46,
      45, 44, 45, 44,
      43, 42, 43, 42,
      39, 38, 39, 38,
      37, 36, 37, 36,
      33, 32, 33, 32,
      31, 30, 31, 30,
      27, 26, 27, 26,
      25, 24, 23, 22,
      23, 22, 19, 18,
      19, 18, 17, 16,
      15, 14, 13, 12,
      11, 10,  9,  8,
       9,  8,  5,  4,
       5,  4,  3,  2,
       1,  0,  0,  1,
       2,  3,  4,  5,
       6,  7,  8,  9,
      10, 11, 12, 13,
      14, 15, 16, 17,
      18, 19, 20, 21,
      22, 23, 24, 25,
      26, 27, 28, 29,
      30, 31, 32, 33,
      34, 35, 36, 37,
      38, 39, 40, 41,
      42, 43, 44, 45,
      46, 47, 48, 49,
      50, 51, 52, 53,
      54, 55, 56, 57,
      58, 59, 60, 61,
      62, 63, 64, 65,
      66, 67, 68, 69,
      70, 71, 72, 73,
      74, 75, 76, 77,
      78, 79, 80, 81,
      82, 83, 84, 85,
      86, 87, 88, 89,
      90, 91, 92, 93,
      94, 95, 96, 97,
      98, 99,100,101,
     102,103,104,105,
     106,107,108,109,
     110,111,112,113,
     114,115,116,117,
     118,119,120,121,
     122,123,124,125,
     124,125,126,127,
};
static const VO_U8 vo_h264_lps_range[4*2*64]=
{
    128,128,128,128,128,128,123,123,
     116,116,111,111,105,105,100,100,
      95, 95, 90, 90, 85, 85, 81, 81,
      77, 77, 73, 73, 69, 69, 66, 66,
      62, 62, 59, 59, 56, 56, 53, 53,
      51, 51, 48, 48, 46, 46, 43, 43,
      41, 41, 39, 39, 37, 37, 35, 35,
      33, 33, 32, 32, 30, 30, 29, 29,
      27, 27, 26, 26, 24, 24, 23, 23,
      22, 22, 21, 21, 20, 20, 19, 19,
      18, 18, 17, 17, 16, 16, 15, 15,
      14, 14, 14, 14, 13, 13, 12, 12,
      12, 12, 11, 11, 11, 11, 10, 10,
      10, 10,  9,  9,  9,  9,  8,  8,
       8,  8,  7,  7,  7,  7,  7,  7,
       6,  6,  6,  6,  6,  6,  2,  2,
     176,176,167,167,158,158,150,150,
     142,142,135,135,128,128,122,122,
     116,116,110,110,104,104, 99, 99,
      94, 94, 89, 89, 85, 85, 80, 80,
      76, 76, 72, 72, 69, 69, 65, 65,
      62, 62, 59, 59, 56, 56, 53, 53,
      50, 50, 48, 48, 45, 45, 43, 43,
      41, 41, 39, 39, 37, 37, 35, 35,
      33, 33, 31, 31, 30, 30, 28, 28,
      27, 27, 26, 26, 24, 24, 23, 23,
      22, 22, 21, 21, 20, 20, 19, 19,
      18, 18, 17, 17, 16, 16, 15, 15,
      14, 14, 14, 14, 13, 13, 12, 12,
      12, 12, 11, 11, 11, 11, 10, 10,
       9,  9,  9,  9,  9,  9,  8,  8,
       8,  8,  7,  7,  7,  7,  2,  2,
     208,208,197,197,187,187,178,178,
     169,169,160,160,152,152,144,144,
     137,137,130,130,123,123,117,117,
     111,111,105,105,100,100, 95, 95,
      90, 90, 86, 86, 81, 81, 77, 77,
      73, 73, 69, 69, 66, 66, 63, 63,
      59, 59, 56, 56, 54, 54, 51, 51,
      48, 48, 46, 46, 43, 43, 41, 41,
      39, 39, 37, 37, 35, 35, 33, 33,
      32, 32, 30, 30, 29, 29, 27, 27,
      26, 26, 25, 25, 23, 23, 22, 22,
      21, 21, 20, 20, 19, 19, 18, 18,
      17, 17, 16, 16, 15, 15, 15, 15,
      14, 14, 13, 13, 12, 12, 12, 12,
      11, 11, 11, 11, 10, 10, 10, 10,
       9,  9,  9,  9,  8,  8,  2,  2,
     240,240,227,227,216,216,205,205,
     195,195,185,185,175,175,166,166,
     158,158,150,150,142,142,135,135,
     128,128,122,122,116,116,110,110,
     104,104, 99, 99, 94, 94, 89, 89,
      85, 85, 80, 80, 76, 76, 72, 72,
      69, 69, 65, 65, 62, 62, 59, 59,
      56, 56, 53, 53, 50, 50, 48, 48,
      45, 45, 43, 43, 41, 41, 39, 39,
      37, 37, 35, 35, 33, 33, 31, 31,
      30, 30, 28, 28, 27, 27, 25, 25,
      24, 24, 23, 23, 22, 22, 21, 21,
      20, 20, 19, 19, 18, 18, 17, 17,
      16, 16, 15, 15, 14, 14, 14, 14,
      13, 13, 12, 12, 12, 12, 11, 11,
      11, 11, 10, 10,  9,  9,  2,  2,
};

static const VO_U8 vo_h264_mps_state[2*64]=
{
	 2,  3,
	  4,  5,
	  6,  7,
	  8,  9,
	 10, 11,
	 12, 13,
	 14, 15,
	 16, 17,
	 18, 19,
	 20, 21,
	 22, 23,
	 24, 25,
	 26, 27,
	 28, 29,
	 30, 31,
	 32, 33,
	 34, 35,
	 36, 37,
	 38, 39,
	 40, 41,
	 42, 43,
	 44, 45,
	 46, 47,
	 48, 49,
	 50, 51,
	 52, 53,
	 54, 55,
	 56, 57,
	 58, 59,
	 60, 61,
	 62, 63,
	 64, 65,
	 66, 67,
	 68, 69,
	 70, 71,
	 72, 73,
	 74, 75,
	 76, 77,
	 78, 79,
	 80, 81,
	 82, 83,
	 84, 85,
	 86, 87,
	 88, 89,
	 90, 91,
	 92, 93,
	 94, 95,
	 96, 97,
	 98, 99,
	100,101,
	102,103,
	104,105,
	106,107,
	108,109,
	110,111,
	112,113,
	114,115,
	116,117,
	118,119,
	120,121,
	122,123,
	124,125,
	124,125,
	126,127,

};

// static const byte renorm_table_32[32]={6,5,4,4,3,3,3,3,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};

#if !defined(ARM) || defined(_WIN32_WCE)
static const VO_U8 vo_h264_norm_shift[512]= {
	9,8,7,7,6,6,6,6,5,5,5,5,5,5,5,5,
	4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
	2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};
#endif

static const VO_S8 vo_cabac_init_I[460][2] =
{
  {0x14,0xf1},{0x02,0x36},{0x03,0x4a},{0x14,0xf1},{0x02,0x36},{0x03,0x4a},
  {0xe4,0x7f},{0xe9,0x68},{0xfa,0x35},{0xff,0x36},{0x07,0x33},{0x00,0x00},
  {0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},
  {0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},
{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},
{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},
{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},
{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},
{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},
{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},{0x00,0x00},
{0x00,0x29},{0x00,0x3f},{0x00,0x3f},{0x00,0x3f},{0xf7,0x53},{0x04,0x56},
{0x00,0x61},{0xf9,0x48},{0x0d,0x29},{0x03,0x3e},{0x00,0x0b},{0x01,0x37},
{0x00,0x45},{0xef,0x7f},{0xf3,0x66},{0x00,0x52},{0xf9,0x4a},{0xeb,0x6b},
{0xe5,0x7f},{0xe1,0x7f},{0xe8,0x7f},{0xee,0x5f},{0xe5,0x7f},{0xeb,0x72},
{0xe2,0x7f},{0xef,0x7b},{0xf4,0x73},{0xf0,0x7a},{0xf5,0x73},{0xf4,0x3f},
{0xfe,0x44},{0xf1,0x54},{0xf3,0x68},{0xfd,0x46},{0xf8,0x5d},{0xf6,0x5a},
{0xe2,0x7f},{0xff,0x4a},{0xfa,0x61},{0xf9,0x5b},{0xec,0x7f},{0xfc,0x38},
{0xfb,0x52},{0xf9,0x4c},{0xea,0x7d},{0xf9,0x5d},{0xf5,0x57},{0xfd,0x4d},
{0xfb,0x47},{0xfc,0x3f},{0xfc,0x44},{0xf4,0x54},{0xf9,0x3e},{0xf9,0x41},
{0x08,0x3d},{0x05,0x38},{0xfe,0x42},{0x01,0x40},{0x00,0x3d},{0xfe,0x4e},
{0x01,0x32},{0x07,0x34},{0x0a,0x23},{0x00,0x2c},{0x0b,0x26},{0x01,0x2d},
{0x00,0x2e},{0x05,0x2c},{0x1f,0x11},{0x01,0x33},{0x07,0x32},{0x1c,0x13},
{0x10,0x21},{0x0e,0x3e},{0xf3,0x6c},{0xf1,0x64},{0xf3,0x65},{0xf3,0x5b},
{0xf4,0x5e},{0xf6,0x58},{0xf0,0x54},{0xf6,0x56},{0xf9,0x53},{0xf3,0x57},
{0xed,0x5e},{0x01,0x46},{0x00,0x48},{0xfb,0x4a},{0x12,0x3b},{0xf8,0x66},
{0xf1,0x64},{0x00,0x5f},{0xfc,0x4b},{0x02,0x48},{0xf5,0x4b},{0xfd,0x47},
{0x0f,0x2e},{0xf3,0x45},{0x00,0x3e},{0x00,0x41},{0x15,0x25},{0xf1,0x48},
{0x09,0x39},{0x10,0x36},{0x00,0x3e},{0x0c,0x48},{0x18,0x00},{0x0f,0x09},
{0x08,0x19},{0x0d,0x12},{0x0f,0x09},{0x0d,0x13},{0x0a,0x25},{0x0c,0x12},
{0x06,0x1d},{0x14,0x21},{0x0f,0x1e},{0x04,0x2d},{0x01,0x3a},{0x00,0x3e},
{0x07,0x3d},{0x0c,0x26},{0x0b,0x2d},{0x0f,0x27},{0x0b,0x2a},{0x0d,0x2c},
{0x10,0x2d},{0x0c,0x29},{0x0a,0x31},{0x1e,0x22},{0x12,0x2a},{0x0a,0x37},
{0x11,0x33},{0x11,0x2e},{0x00,0x59},{0x1a,0xed},{0x16,0xef},{0x1a,0xef},
{0x1e,0xe7},{0x1c,0xec},{0x21,0xe9},{0x25,0xe5},{0x21,0xe9},{0x28,0xe4},
{0x26,0xef},{0x21,0xf5},{0x28,0xf1},{0x29,0xfa},{0x26,0x01},{0x29,0x11},
{0x1e,0xfa},{0x1b,0x03},{0x1a,0x16},{0x25,0xf0},{0x23,0xfc},{0x26,0xf8},
{0x26,0xfd},{0x25,0x03},{0x26,0x05},{0x2a,0x00},{0x23,0x10},{0x27,0x16},
{0x0e,0x30},{0x1b,0x25},{0x15,0x3c},{0x0c,0x44},{0x02,0x61},{0xfd,0x47},
{0xfa,0x2a},{0xfb,0x32},{0xfd,0x36},{0xfe,0x3e},{0x00,0x3a},{0x01,0x3f},
{0xfe,0x48},{0xff,0x4a},{0xf7,0x5b},{0xfb,0x43},{0xfb,0x1b},{0xfd,0x27},
{0xfe,0x2c},{0x00,0x2e},{0xf0,0x40},{0xf8,0x44},{0xf6,0x4e},{0xfa,0x4d},
{0xf6,0x56},{0xf4,0x5c},{0xf1,0x37},{0xf6,0x3c},{0xfa,0x3e},{0xfc,0x41},
{0xf4,0x49},{0xf8,0x4c},{0xf9,0x50},{0xf7,0x58},{0xef,0x6e},{0xf5,0x61},
{0xec,0x54},{0xf5,0x4f},{0xfa,0x49},{0xfc,0x4a},{0xf3,0x56},{0xf3,0x60},
{0xf5,0x61},{0xed,0x75},{0xf8,0x4e},{0xfb,0x21},{0xfc,0x30},{0xfe,0x35},
{0xfd,0x3e},{0xf3,0x47},{0xf6,0x4f},{0xf4,0x56},{0xf3,0x5a},{0xf2,0x61},
{0x00,0x00},{0xfa,0x5d},{0xfa,0x54},{0xf8,0x4f},{0x00,0x42},{0xff,0x47},
{0x00,0x3e},{0xfe,0x3c},{0xfe,0x3b},{0xfb,0x4b},{0xfd,0x3e},{0xfc,0x3a},
{0xf7,0x42},{0xff,0x4f},{0x00,0x47},{0x03,0x44},{0x0a,0x2c},{0xf9,0x3e},
{0x0f,0x24},{0x0e,0x28},{0x10,0x1b},{0x0c,0x1d},{0x01,0x2c},{0x14,0x24},
{0x12,0x20},{0x05,0x2a},{0x01,0x30},{0x0a,0x3e},{0x11,0x2e},{0x09,0x40},
{0xf4,0x68},{0xf5,0x61},{0xf0,0x60},{0xf9,0x58},{0xf8,0x55},{0xf9,0x55},
{0xf7,0x55},{0xf3,0x58},{0x04,0x42},{0xfd,0x4d},{0xfd,0x4c},{0xfa,0x4c},
{0x0a,0x3a},{0xff,0x4c},{0xff,0x53},{0xf9,0x63},{0xf2,0x5f},{0x02,0x5f},
{0x00,0x4c},{0xfb,0x4a},{0x00,0x46},{0xf5,0x4b},{0x01,0x44},{0x00,0x41},
{0xf2,0x49},{0x03,0x3e},{0x04,0x3e},{0xff,0x44},{0xf3,0x4b},{0x0b,0x37},
{0x05,0x40},{0x0c,0x46},{0x0f,0x06},{0x06,0x13},{0x07,0x10},{0x0c,0x0e},
{0x12,0x0d},{0x0d,0x0b},{0x0d,0x0f},{0x0f,0x10},{0x0c,0x17},{0x0d,0x17},
{0x0f,0x14},{0x0e,0x1a},{0x0e,0x2c},{0x11,0x28},{0x11,0x2f},{0x18,0x11},
{0x15,0x15},{0x19,0x16},{0x1f,0x1b},{0x16,0x1d},{0x13,0x23},{0x0e,0x32},
{0x0a,0x39},{0x07,0x3f},{0xfe,0x4d},{0xfc,0x52},{0xfd,0x5e},{0x09,0x45},
{0xf4,0x6d},{0x24,0xdd},{0x24,0xde},{0x20,0xe6},{0x25,0xe2},{0x2c,0xe0},
{0x22,0xee},{0x22,0xf1},{0x28,0xf1},{0x21,0xf9},{0x23,0xfb},{0x21,0x00},
{0x26,0x02},{0x21,0x0d},{0x17,0x23},{0x0d,0x3a},{0x1d,0xfd},{0x1a,0x00},
{0x16,0x1e},{0x1f,0xf9},{0x23,0xf1},{0x22,0xfd},{0x22,0x03},{0x24,0xff},
{0x22,0x05},{0x20,0x0b},{0x23,0x05},{0x22,0x0c},{0x27,0x0b},{0x1e,0x1d},
{0x22,0x1a},{0x1d,0x27},{0x13,0x42},{0x1f,0x15},{0x1f,0x1f},{0x19,0x32},
{0xef,0x78},{0xec,0x70},{0xee,0x72},{0xf5,0x55},{0xf1,0x5c},{0xf2,0x59},
{0xe6,0x47},{0xf1,0x51},{0xf2,0x50},{0x00,0x44},{0xf2,0x46},{0xe8,0x38},
{0xe9,0x44},{0xe8,0x32},{0xf5,0x4a},{0x17,0xf3},{0x1a,0xf3},{0x28,0xf1},
{0x31,0xf2},{0x2c,0x03},{0x2d,0x06},{0x2c,0x22},{0x21,0x36},{0x13,0x52},
{0xfd,0x4b},{0xff,0x17},{0x01,0x22},{0x01,0x2b},{0x00,0x36},{0xfe,0x37},
{0x00,0x3d},{0x01,0x40},{0x00,0x44},{0xf7,0x5c},{0xf2,0x6a},{0xf3,0x61},
{0xf1,0x5a},{0xf4,0x5a},{0xee,0x58},{0xf6,0x49},{0xf7,0x4f},{0xf2,0x56},
{0xf6,0x49},{0xf6,0x46},{0xf6,0x45},{0xfb,0x42},{0xf7,0x40},{0xfb,0x3a},
{0x02,0x3b},{0x15,0xf6},{0x18,0xf5},{0x1c,0xf8},{0x1c,0xff},{0x1d,0x03},
{0x1d,0x09},{0x23,0x14},{0x1d,0x24},{0x0e,0x43},

};

static const VO_S8 vo_cabac_init_PB[3][460][2] =
{
    {
        {0x14,0xf1},{0x02,0x36},{0x03,0x4a},{0x14,0xf1},{0x02,0x36},{0x03,0x4a},
{0xe4,0x7f},{0xe9,0x68},{0xfa,0x35},{0xff,0x36},{0x07,0x33},{0x17,0x21},
{0x17,0x02},{0x15,0x00},{0x01,0x09},{0x00,0x31},{0xdb,0x76},{0x05,0x39},
{0xf3,0x4e},{0xf5,0x41},{0x01,0x3e},{0x0c,0x31},{0xfc,0x49},{0x11,0x32},
{0x12,0x40},{0x09,0x2b},{0x1d,0x00},{0x1a,0x43},{0x10,0x5a},{0x09,0x68},
{0xd2,0x7f},{0xec,0x68},{0x01,0x43},{0xf3,0x4e},{0xf5,0x41},{0x01,0x3e},
{0xfa,0x56},{0xef,0x5f},{0xfa,0x3d},{0x09,0x2d},{0xfd,0x45},{0xfa,0x51},
{0xf5,0x60},{0x06,0x37},{0x07,0x43},{0xfb,0x56},{0x02,0x58},{0x00,0x3a},
{0xfd,0x4c},{0xf6,0x5e},{0x05,0x36},{0x04,0x45},{0xfd,0x51},{0x00,0x58},
{0xf9,0x43},{0xfb,0x4a},{0xfc,0x4a},{0xfb,0x50},{0xf9,0x48},{0x01,0x3a},
{0x00,0x29},{0x00,0x3f},{0x00,0x3f},{0x00,0x3f},{0xf7,0x53},{0x04,0x56},
{0x00,0x61},{0xf9,0x48},{0x0d,0x29},{0x03,0x3e},{0x00,0x2d},{0xfc,0x4e},
{0xfd,0x60},{0xe5,0x7e},{0xe4,0x62},{0xe7,0x65},{0xe9,0x43},{0xe4,0x52},
{0xec,0x5e},{0xf0,0x53},{0xea,0x6e},{0xeb,0x5b},{0xee,0x66},{0xf3,0x5d},
{0xe3,0x7f},{0xf9,0x5c},{0xfb,0x59},{0xf9,0x60},{0xf3,0x6c},{0xfd,0x2e},
{0xff,0x41},{0xff,0x39},{0xf7,0x5d},{0xfd,0x4a},{0xf7,0x5c},{0xf8,0x57},
{0xe9,0x7e},{0x05,0x36},{0x06,0x3c},{0x06,0x3b},{0x06,0x45},{0xff,0x30},
{0x00,0x44},{0xfc,0x45},{0xf8,0x58},{0xfe,0x55},{0xfa,0x4e},{0xff,0x4b},
{0xf9,0x4d},{0x02,0x36},{0x05,0x32},{0xfd,0x44},{0x01,0x32},{0x06,0x2a},
{0xfc,0x51},{0x01,0x3f},{0xfc,0x46},{0x00,0x43},{0x02,0x39},{0xfe,0x4c},
{0x0b,0x23},{0x04,0x40},{0x01,0x3d},{0x0b,0x23},{0x12,0x19},{0x0c,0x18},
{0x0d,0x1d},{0x0d,0x24},{0xf6,0x5d},{0xf9,0x49},{0xfe,0x49},{0x0d,0x2e},
{0x09,0x31},{0xf9,0x64},{0x09,0x35},{0x02,0x35},{0x05,0x35},{0xfe,0x3d},
{0x00,0x38},{0x00,0x38},{0xf3,0x3f},{0xfb,0x3c},{0xff,0x3e},{0x04,0x39},
{0xfa,0x45},{0x04,0x39},{0x0e,0x27},{0x04,0x33},{0x0d,0x44},{0x03,0x40},
{0x01,0x3d},{0x09,0x3f},{0x07,0x32},{0x10,0x27},{0x05,0x2c},{0x04,0x34},
{0x0b,0x30},{0xfb,0x3c},{0xff,0x3b},{0x00,0x3b},{0x16,0x21},{0x05,0x2c},
{0x0e,0x2b},{0xff,0x4e},{0x00,0x3c},{0x09,0x45},{0x0b,0x1c},{0x02,0x28},
{0x03,0x2c},{0x00,0x31},{0x00,0x2e},{0x02,0x2c},{0x02,0x33},{0x00,0x2f},
{0x04,0x27},{0x02,0x3e},{0x06,0x2e},{0x00,0x36},{0x03,0x36},{0x02,0x3a},
{0x04,0x3f},{0x06,0x33},{0x06,0x39},{0x07,0x35},{0x06,0x34},{0x06,0x37},
{0x0b,0x2d},{0x0e,0x24},{0x08,0x35},{0xff,0x52},{0x07,0x37},{0xfd,0x4e},
{0x0f,0x2e},{0x16,0x1f},{0xff,0x54},{0x19,0x07},{0x1e,0xf9},{0x1c,0x03},
{0x1c,0x04},{0x20,0x00},{0x22,0xff},{0x1e,0x06},{0x1e,0x06},{0x20,0x09},
{0x1f,0x13},{0x1a,0x1b},{0x1a,0x1e},{0x25,0x14},{0x1c,0x22},{0x11,0x46},
{0x01,0x43},{0x05,0x3b},{0x09,0x43},{0x10,0x1e},{0x12,0x20},{0x12,0x23},
{0x16,0x1d},{0x18,0x1f},{0x17,0x26},{0x12,0x2b},{0x14,0x29},{0x0b,0x3f},
{0x09,0x3b},{0x09,0x40},{0xff,0x5e},{0xfe,0x59},{0xf7,0x6c},{0xfa,0x4c},
{0xfe,0x2c},{0x00,0x2d},{0x00,0x34},{0xfd,0x40},{0xfe,0x3b},{0xfc,0x46},
{0xfc,0x4b},{0xf8,0x52},{0xef,0x66},{0xf7,0x4d},{0x03,0x18},{0x00,0x2a},
{0x00,0x30},{0x00,0x37},{0xfa,0x3b},{0xf9,0x47},{0xf4,0x53},{0xf5,0x57},
{0xe2,0x77},{0x01,0x3a},{0xfd,0x1d},{0xff,0x24},{0x01,0x26},{0x02,0x2b},
{0xfa,0x37},{0x00,0x3a},{0x00,0x40},{0xfd,0x4a},{0xf6,0x5a},{0x00,0x46},
{0xfc,0x1d},{0x05,0x1f},{0x07,0x2a},{0x01,0x3b},{0xfe,0x3a},{0xfd,0x48},
{0xfd,0x51},{0xf5,0x61},{0x00,0x3a},{0x08,0x05},{0x0a,0x0e},{0x0e,0x12},
{0x0d,0x1b},{0x02,0x28},{0x00,0x3a},{0xfd,0x46},{0xfa,0x4f},{0xf8,0x55},
{0x00,0x00},{0xf3,0x6a},{0xf0,0x6a},{0xf6,0x57},{0xeb,0x72},{0xee,0x6e},
{0xf2,0x62},{0xea,0x6e},{0xeb,0x6a},{0xee,0x67},{0xeb,0x6b},{0xe9,0x6c},
{0xe6,0x70},{0xf6,0x60},{0xf4,0x5f},{0xfb,0x5b},{0xf7,0x5d},{0xea,0x5e},
{0xfb,0x56},{0x09,0x43},{0xfc,0x50},{0xf6,0x55},{0xff,0x46},{0x07,0x3c},
{0x09,0x3a},{0x05,0x3d},{0x0c,0x32},{0x0f,0x32},{0x12,0x31},{0x11,0x36},
{0x0a,0x29},{0x07,0x2e},{0xff,0x33},{0x07,0x31},{0x08,0x34},{0x09,0x29},
{0x06,0x2f},{0x02,0x37},{0x0d,0x29},{0x0a,0x2c},{0x06,0x32},{0x05,0x35},
{0x0d,0x31},{0x04,0x3f},{0x06,0x40},{0xfe,0x45},{0xfe,0x3b},{0x06,0x46},
{0x0a,0x2c},{0x09,0x1f},{0x0c,0x2b},{0x03,0x35},{0x0e,0x22},{0x0a,0x26},
{0xfd,0x34},{0x0d,0x28},{0x11,0x20},{0x07,0x2c},{0x07,0x26},{0x0d,0x32},
{0x0a,0x39},{0x1a,0x2b},{0x0e,0x0b},{0x0b,0x0e},{0x09,0x0b},{0x12,0x0b},
{0x15,0x09},{0x17,0xfe},{0x20,0xf1},{0x20,0xf1},{0x22,0xeb},{0x27,0xe9},
{0x2a,0xdf},{0x29,0xe1},{0x2e,0xe4},{0x26,0xf4},{0x15,0x1d},{0x2d,0xe8},
{0x35,0xd3},{0x30,0xe6},{0x41,0xd5},{0x2b,0xed},{0x27,0xf6},{0x1e,0x09},
{0x12,0x1a},{0x14,0x1b},{0x00,0x39},{0xf2,0x52},{0xfb,0x4b},{0xed,0x61},
{0xdd,0x7d},{0x1b,0x00},{0x1c,0x00},{0x1f,0xfc},{0x1b,0x06},{0x22,0x08},
{0x1e,0x0a},{0x18,0x16},{0x21,0x13},{0x16,0x20},{0x1a,0x1f},{0x15,0x29},
{0x1a,0x2c},{0x17,0x2f},{0x10,0x41},{0x0e,0x47},{0x08,0x3c},{0x06,0x3f},
{0x11,0x41},{0x15,0x18},{0x17,0x14},{0x1a,0x17},{0x1b,0x20},{0x1c,0x17},
{0x1c,0x18},{0x17,0x28},{0x18,0x20},{0x1c,0x1d},{0x17,0x2a},{0x13,0x39},
{0x16,0x35},{0x16,0x3d},{0x0b,0x56},{0x0c,0x28},{0x0b,0x33},{0x0e,0x3b},
{0xfc,0x4f},{0xf9,0x47},{0xfb,0x45},{0xf7,0x46},{0xf8,0x42},{0xf6,0x44},
{0xed,0x49},{0xf4,0x45},{0xf0,0x46},{0xf1,0x43},{0xec,0x3e},{0xed,0x46},
{0xf0,0x42},{0xea,0x41},{0xec,0x3f},{0x09,0xfe},{0x1a,0xf7},{0x21,0xf7},
{0x27,0xf9},{0x29,0xfe},{0x2d,0x03},{0x31,0x09},{0x2d,0x1b},{0x24,0x3b},
{0xfa,0x42},{0xf9,0x23},{0xf9,0x2a},{0xf8,0x2d},{0xfb,0x30},{0xf4,0x38},
{0xfa,0x3c},{0xfb,0x3e},{0xf8,0x42},{0xf8,0x4c},{0xfb,0x55},{0xfa,0x51},
{0xf6,0x4d},{0xf9,0x51},{0xef,0x50},{0xee,0x49},{0xfc,0x4a},{0xf6,0x53},
{0xf7,0x47},{0xf7,0x43},{0xff,0x3d},{0xf8,0x42},{0xf2,0x42},{0x00,0x3b},
{0x02,0x3b},{0x15,0xf3},{0x21,0xf2},{0x27,0xf9},{0x2e,0xfe},{0x33,0x02},
{0x3c,0x06},{0x3d,0x11},{0x37,0x22},{0x2a,0x3e},
    },

    {
        {0x14,0xf1},{0x02,0x36},{0x03,0x4a},{0x14,0xf1},{0x02,0x36},{0x03,0x4a},
{0xe4,0x7f},{0xe9,0x68},{0xfa,0x35},{0xff,0x36},{0x07,0x33},{0x16,0x19},
{0x22,0x00},{0x10,0x00},{0xfe,0x09},{0x04,0x29},{0xe3,0x76},{0x02,0x41},
{0xfa,0x47},{0xf3,0x4f},{0x05,0x34},{0x09,0x32},{0xfd,0x46},{0x0a,0x36},
{0x1a,0x22},{0x13,0x16},{0x28,0x00},{0x39,0x02},{0x29,0x24},{0x1a,0x45},
{0xd3,0x7f},{0xf1,0x65},{0xfc,0x4c},{0xfa,0x47},{0xf3,0x4f},{0x05,0x34},
{0x06,0x45},{0xf3,0x5a},{0x00,0x34},{0x08,0x2b},{0xfe,0x45},{0xfb,0x52},
{0xf6,0x60},{0x02,0x3b},{0x02,0x4b},{0xfd,0x57},{0xfd,0x64},{0x01,0x38},
{0xfd,0x4a},{0xfa,0x55},{0x00,0x3b},{0xfd,0x51},{0xf9,0x56},{0xfb,0x5f},
{0xff,0x42},{0xff,0x4d},{0x01,0x46},{0xfe,0x56},{0xfb,0x48},{0x00,0x3d},
{0x00,0x29},{0x00,0x3f},{0x00,0x3f},{0x00,0x3f},{0xf7,0x53},{0x04,0x56},
{0x00,0x61},{0xf9,0x48},{0x0d,0x29},{0x03,0x3e},{0x0d,0x0f},{0x07,0x33},
{0x02,0x50},{0xd9,0x7f},{0xee,0x5b},{0xef,0x60},{0xe6,0x51},{0xdd,0x62},
{0xe8,0x66},{0xe9,0x61},{0xe5,0x77},{0xe8,0x63},{0xeb,0x6e},{0xee,0x66},
{0xdc,0x7f},{0x00,0x50},{0xfb,0x59},{0xf9,0x5e},{0xfc,0x5c},{0x00,0x27},
{0x00,0x41},{0xf1,0x54},{0xdd,0x7f},{0xfe,0x49},{0xf4,0x68},{0xf7,0x5b},
{0xe1,0x7f},{0x03,0x37},{0x07,0x38},{0x07,0x37},{0x08,0x3d},{0xfd,0x35},
{0x00,0x44},{0xf9,0x4a},{0xf7,0x58},{0xf3,0x67},{0xf3,0x5b},{0xf7,0x59},
{0xf2,0x5c},{0xf8,0x4c},{0xf4,0x57},{0xe9,0x6e},{0xe8,0x69},{0xf6,0x4e},
{0xec,0x70},{0xef,0x63},{0xb2,0x7f},{0xba,0x7f},{0xce,0x7f},{0xd2,0x7f},
{0xfc,0x42},{0xfb,0x4e},{0xfc,0x47},{0xf8,0x48},{0x02,0x3b},{0xff,0x37},
{0xf9,0x46},{0xfa,0x4b},{0xf8,0x59},{0xde,0x77},{0xfd,0x4b},{0x20,0x14},
{0x1e,0x16},{0xd4,0x7f},{0x00,0x36},{0xfb,0x3d},{0x00,0x3a},{0xff,0x3c},
{0xfd,0x3d},{0xf8,0x43},{0xe7,0x54},{0xf2,0x4a},{0xfb,0x41},{0x05,0x34},
{0x02,0x39},{0x00,0x3d},{0xf7,0x45},{0xf5,0x46},{0x12,0x37},{0xfc,0x47},
{0x00,0x3a},{0x07,0x3d},{0x09,0x29},{0x12,0x19},{0x09,0x20},{0x05,0x2b},
{0x09,0x2f},{0x00,0x2c},{0x00,0x33},{0x02,0x2e},{0x13,0x26},{0xfc,0x42},
{0x0f,0x26},{0x0c,0x2a},{0x09,0x22},{0x00,0x59},{0x04,0x2d},{0x0a,0x1c},
{0x0a,0x1f},{0x21,0xf5},{0x34,0xd5},{0x12,0x0f},{0x1c,0x00},{0x23,0xea},
{0x26,0xe7},{0x22,0x00},{0x27,0xee},{0x20,0xf4},{0x66,0xa2},{0x00,0x00},
{0x38,0xf1},{0x21,0xfc},{0x1d,0x0a},{0x25,0xfb},{0x33,0xe3},{0x27,0xf7},
{0x34,0xde},{0x45,0xc6},{0x43,0xc1},{0x2c,0xfb},{0x20,0x07},{0x37,0xe3},
{0x20,0x01},{0x00,0x00},{0x1b,0x24},{0x21,0xe7},{0x22,0xe2},{0x24,0xe4},
{0x26,0xe4},{0x26,0xe5},{0x22,0xee},{0x23,0xf0},{0x22,0xf2},{0x20,0xf8},
{0x25,0xfa},{0x23,0x00},{0x1e,0x0a},{0x1c,0x12},{0x1a,0x19},{0x1d,0x29},
{0x00,0x4b},{0x02,0x48},{0x08,0x4d},{0x0e,0x23},{0x12,0x1f},{0x11,0x23},
{0x15,0x1e},{0x11,0x2d},{0x14,0x2a},{0x12,0x2d},{0x1b,0x1a},{0x10,0x36},
{0x07,0x42},{0x10,0x38},{0x0b,0x49},{0x0a,0x43},{0xf6,0x74},{0xe9,0x70},
{0xf1,0x47},{0xf9,0x3d},{0x00,0x35},{0xfb,0x42},{0xf5,0x4d},{0xf7,0x50},
{0xf7,0x54},{0xf6,0x57},{0xde,0x7f},{0xeb,0x65},{0xfd,0x27},{0xfb,0x35},
{0xf9,0x3d},{0xf5,0x4b},{0xf1,0x4d},{0xef,0x5b},{0xe7,0x6b},{0xe7,0x6f},
{0xe4,0x7a},{0xf5,0x4c},{0xf6,0x2c},{0xf6,0x34},{0xf6,0x39},{0xf7,0x3a},
{0xf0,0x48},{0xf9,0x45},{0xfc,0x45},{0xfb,0x4a},{0xf7,0x56},{0x02,0x42},
{0xf7,0x22},{0x01,0x20},{0x0b,0x1f},{0x05,0x34},{0xfe,0x37},{0xfe,0x43},
{0x00,0x49},{0xf8,0x59},{0x03,0x34},{0x07,0x04},{0x0a,0x08},{0x11,0x08},
{0x10,0x13},{0x03,0x25},{0xff,0x3d},{0xfb,0x49},{0xff,0x46},{0xfc,0x4e},
{0x00,0x00},{0xeb,0x7e},{0xe9,0x7c},{0xec,0x6e},{0xe6,0x7e},{0xe7,0x7c},
{0xef,0x69},{0xe5,0x79},{0xe5,0x75},{0xef,0x66},{0xe6,0x75},{0xe5,0x74},
{0xdf,0x7a},{0xf6,0x5f},{0xf2,0x64},{0xf8,0x5f},{0xef,0x6f},{0xe4,0x72},
{0xfa,0x59},{0xfe,0x50},{0xfc,0x52},{0xf7,0x55},{0xf8,0x51},{0xff,0x48},
{0x05,0x40},{0x01,0x43},{0x09,0x38},{0x00,0x45},{0x01,0x45},{0x07,0x45},
{0xf9,0x45},{0xfa,0x43},{0xf0,0x4d},{0xfe,0x40},{0x02,0x3d},{0xfa,0x43},
{0xfd,0x40},{0x02,0x39},{0xfd,0x41},{0xfd,0x42},{0x00,0x3e},{0x09,0x33},
{0xff,0x42},{0xfe,0x47},{0xfe,0x4b},{0xff,0x46},{0xf7,0x48},{0x0e,0x3c},
{0x10,0x25},{0x00,0x2f},{0x12,0x23},{0x0b,0x25},{0x0c,0x29},{0x0a,0x29},
{0x02,0x30},{0x0c,0x29},{0x0d,0x29},{0x00,0x3b},{0x03,0x32},{0x13,0x28},
{0x03,0x42},{0x12,0x32},{0x13,0xfa},{0x12,0xfa},{0x0e,0x00},{0x1a,0xf4},
{0x1f,0xf0},{0x21,0xe7},{0x21,0xea},{0x25,0xe4},{0x27,0xe2},{0x2a,0xe2},
{0x2f,0xd6},{0x2d,0xdc},{0x31,0xde},{0x29,0xef},{0x20,0x09},{0x45,0xb9},
{0x3f,0xc1},{0x42,0xc0},{0x4d,0xb6},{0x36,0xd9},{0x34,0xdd},{0x29,0xf6},
{0x24,0x00},{0x28,0xff},{0x1e,0x0e},{0x1c,0x1a},{0x17,0x25},{0x0c,0x37},
{0x0b,0x41},{0x25,0xdf},{0x27,0xdc},{0x28,0xdb},{0x26,0xe2},{0x2e,0xdf},
{0x2a,0xe2},{0x28,0xe8},{0x31,0xe3},{0x26,0xf4},{0x28,0xf6},{0x26,0xfd},
{0x2e,0xfb},{0x1f,0x14},{0x1d,0x1e},{0x19,0x2c},{0x0c,0x30},{0x0b,0x31},
{0x1a,0x2d},{0x16,0x16},{0x17,0x16},{0x1b,0x15},{0x21,0x14},{0x1a,0x1c},
{0x1e,0x18},{0x1b,0x22},{0x12,0x2a},{0x19,0x27},{0x12,0x32},{0x0c,0x46},
{0x15,0x36},{0x0e,0x47},{0x0b,0x53},{0x19,0x20},{0x15,0x31},{0x15,0x36},
{0xfb,0x55},{0xfa,0x51},{0xf6,0x4d},{0xf9,0x51},{0xef,0x50},{0xee,0x49},
{0xfc,0x4a},{0xf6,0x53},{0xf7,0x47},{0xf7,0x43},{0xff,0x3d},{0xf8,0x42},
{0xf2,0x42},{0x00,0x3b},{0x02,0x3b},{0x11,0xf6},{0x20,0xf3},{0x2a,0xf7},
{0x31,0xfb},{0x35,0x00},{0x40,0x03},{0x44,0x0a},{0x42,0x1b},{0x2f,0x39},
{0xfb,0x47},{0x00,0x18},{0xff,0x24},{0xfe,0x2a},{0xfe,0x34},{0xf7,0x39},
{0xfa,0x3f},{0xfc,0x41},{0xfc,0x43},{0xf9,0x52},{0xfd,0x51},{0xfd,0x4c},
{0xf9,0x48},{0xfa,0x4e},{0xf4,0x48},{0xf2,0x44},{0xfd,0x46},{0xfa,0x4c},
{0xfb,0x42},{0xfb,0x3e},{0x00,0x39},{0xfc,0x3d},{0xf7,0x3c},{0x01,0x36},
{0x02,0x3a},{0x11,0xf6},{0x20,0xf3},{0x2a,0xf7},{0x31,0xfb},{0x35,0x00},
{0x40,0x03},{0x44,0x0a},{0x42,0x1b},{0x2f,0x39},
    },

    {
        {0x14,0xf1},{0x02,0x36},{0x03,0x4a},{0x14,0xf1},{0x02,0x36},{0x03,0x4a},
{0xe4,0x7f},{0xe9,0x68},{0xfa,0x35},{0xff,0x36},{0x07,0x33},{0x1d,0x10},
{0x19,0x00},{0x0e,0x00},{0xf6,0x33},{0xfd,0x3e},{0xe5,0x63},{0x1a,0x10},
{0xfc,0x55},{0xe8,0x66},{0x05,0x39},{0x06,0x39},{0xef,0x49},{0x0e,0x39},
{0x14,0x28},{0x14,0x0a},{0x1d,0x00},{0x36,0x00},{0x25,0x2a},{0x0c,0x61},
{0xe0,0x7f},{0xea,0x75},{0xfe,0x4a},{0xfc,0x55},{0xe8,0x66},{0x05,0x39},
{0xfa,0x5d},{0xf2,0x58},{0xfa,0x2c},{0x04,0x37},{0xf5,0x59},{0xf1,0x67},
{0xeb,0x74},{0x13,0x39},{0x14,0x3a},{0x04,0x54},{0x06,0x60},{0x01,0x3f},
{0xfb,0x55},{0xf3,0x6a},{0x05,0x3f},{0x06,0x4b},{0xfd,0x5a},{0xff,0x65},
{0x03,0x37},{0xfc,0x4f},{0xfe,0x4b},{0xf4,0x61},{0xf9,0x32},{0x01,0x3c},
{0x00,0x29},{0x00,0x3f},{0x00,0x3f},{0x00,0x3f},{0xf7,0x53},{0x04,0x56},
{0x00,0x61},{0xf9,0x48},{0x0d,0x29},{0x03,0x3e},{0x07,0x22},{0xf7,0x58},
{0xec,0x7f},{0xdc,0x7f},{0xef,0x5b},{0xf2,0x5f},{0xe7,0x54},{0xe7,0x56},
{0xf4,0x59},{0xef,0x5b},{0xe1,0x7f},{0xf2,0x4c},{0xee,0x67},{0xf3,0x5a},
{0xdb,0x7f},{0x0b,0x50},{0x05,0x4c},{0x02,0x54},{0x05,0x4e},{0xfa,0x37},
{0x04,0x3d},{0xf2,0x53},{0xdb,0x7f},{0xfb,0x4f},{0xf5,0x68},{0xf5,0x5b},
{0xe2,0x7f},{0x00,0x41},{0xfe,0x4f},{0x00,0x48},{0xfc,0x5c},{0xfa,0x38},
{0x03,0x44},{0xf8,0x47},{0xf3,0x62},{0xfc,0x56},{0xf4,0x58},{0xfb,0x52},
{0xfd,0x48},{0xfc,0x43},{0xf8,0x48},{0xf0,0x59},{0xf7,0x45},{0xff,0x3b},
{0x05,0x42},{0x04,0x39},{0xfc,0x47},{0xfe,0x47},{0x02,0x3a},{0xff,0x4a},
{0xfc,0x2c},{0xff,0x45},{0x00,0x3e},{0xf9,0x33},{0xfc,0x2f},{0xfa,0x2a},
{0xfd,0x29},{0xfa,0x35},{0x08,0x4c},{0xf7,0x4e},{0xf5,0x53},{0x09,0x34},
{0x00,0x43},{0xfb,0x5a},{0x01,0x43},{0xf1,0x48},{0xfb,0x4b},{0xf8,0x50},
{0xeb,0x53},{0xeb,0x40},{0xf3,0x1f},{0xe7,0x40},{0xe3,0x5e},{0x09,0x4b},
{0x11,0x3f},{0xf8,0x4a},{0xfb,0x23},{0xfe,0x1b},{0x0d,0x5b},{0x03,0x41},
{0xf9,0x45},{0x08,0x4d},{0xf6,0x42},{0x03,0x3e},{0xfd,0x44},{0xec,0x51},
{0x00,0x1e},{0x01,0x07},{0xfd,0x17},{0xeb,0x4a},{0x10,0x42},{0xe9,0x7c},
{0x11,0x25},{0x2c,0xee},{0x32,0xde},{0xea,0x7f},{0x04,0x27},{0x00,0x2a},
{0x07,0x22},{0x0b,0x1d},{0x08,0x1f},{0x06,0x25},{0x07,0x2a},{0x03,0x28},
{0x08,0x21},{0x0d,0x2b},{0x0d,0x24},{0x04,0x2f},{0x03,0x37},{0x02,0x3a},
{0x06,0x3c},{0x08,0x2c},{0x0b,0x2c},{0x0e,0x2a},{0x07,0x30},{0x04,0x38},
{0x04,0x34},{0x0d,0x25},{0x09,0x31},{0x13,0x3a},{0x0a,0x30},{0x0c,0x2d},
{0x00,0x45},{0x14,0x21},{0x08,0x3f},{0x23,0xee},{0x21,0xe7},{0x1c,0xfd},
{0x18,0x0a},{0x1b,0x00},{0x22,0xf2},{0x34,0xd4},{0x27,0xe8},{0x13,0x11},
{0x1f,0x19},{0x24,0x1d},{0x18,0x21},{0x22,0x0f},{0x1e,0x14},{0x16,0x49},
{0x14,0x22},{0x13,0x1f},{0x1b,0x2c},{0x13,0x10},{0x0f,0x24},{0x0f,0x24},
{0x15,0x1c},{0x19,0x15},{0x1e,0x14},{0x1f,0x0c},{0x1b,0x10},{0x18,0x2a},
{0x00,0x5d},{0x0e,0x38},{0x0f,0x39},{0x1a,0x26},{0xe8,0x7f},{0xe8,0x73},
{0xea,0x52},{0xf7,0x3e},{0x00,0x35},{0x00,0x3b},{0xf2,0x55},{0xf3,0x59},
{0xf3,0x5e},{0xf5,0x5c},{0xe3,0x7f},{0xeb,0x64},{0xf2,0x39},{0xf4,0x43},
{0xf5,0x47},{0xf6,0x4d},{0xeb,0x55},{0xf0,0x58},{0xe9,0x68},{0xf1,0x62},
{0xdb,0x7f},{0xf6,0x52},{0xf8,0x30},{0xf8,0x3d},{0xf8,0x42},{0xf9,0x46},
{0xf2,0x4b},{0xf6,0x4f},{0xf7,0x53},{0xf4,0x5c},{0xee,0x6c},{0xfc,0x4f},
{0xea,0x45},{0xf0,0x4b},{0xfe,0x3a},{0x01,0x3a},{0xf3,0x4e},{0xf7,0x53},
{0xfc,0x51},{0xf3,0x63},{0xf3,0x51},{0xfa,0x26},{0xf3,0x3e},{0xfa,0x3a},
{0xfe,0x3b},{0xf0,0x49},{0xf6,0x4c},{0xf3,0x56},{0xf7,0x53},{0xf6,0x57},
{0x00,0x00},{0xea,0x7f},{0xe7,0x7f},{0xe7,0x78},{0xe5,0x7f},{0xed,0x72},
{0xe9,0x75},{0xe7,0x76},{0xe6,0x75},{0xe8,0x71},{0xe4,0x76},{0xe1,0x78},
{0xdb,0x7c},{0xf6,0x5e},{0xf1,0x66},{0xf6,0x63},{0xf3,0x6a},{0xce,0x7f},
{0xfb,0x5c},{0x11,0x39},{0xfb,0x56},{0xf3,0x5e},{0xf4,0x5b},{0xfe,0x4d},
{0x00,0x47},{0xff,0x49},{0x04,0x40},{0xf9,0x51},{0x05,0x40},{0x0f,0x39},
{0x01,0x43},{0x00,0x44},{0xf6,0x43},{0x01,0x44},{0x00,0x4d},{0x02,0x40},
{0x00,0x44},{0xfb,0x4e},{0x07,0x37},{0x05,0x3b},{0x02,0x41},{0x0e,0x36},
{0x0f,0x2c},{0x05,0x3c},{0x02,0x46},{0xfe,0x4c},{0xee,0x56},{0x0c,0x46},
{0x05,0x40},{0xf4,0x46},{0x0b,0x37},{0x05,0x38},{0x00,0x45},{0x02,0x41},
{0xfa,0x4a},{0x05,0x36},{0x07,0x36},{0xfa,0x4c},{0xf5,0x52},{0xfe,0x4d},
{0xfe,0x4d},{0x19,0x2a},{0x11,0xf3},{0x10,0xf7},{0x11,0xf4},{0x1b,0xeb},
{0x25,0xe2},{0x29,0xd8},{0x2a,0xd7},{0x30,0xd1},{0x27,0xe0},{0x2e,0xd8},
{0x34,0xcd},{0x2e,0xd7},{0x34,0xd9},{0x2b,0xed},{0x20,0x0b},{0x3d,0xc9},
{0x38,0xd2},{0x3e,0xce},{0x51,0xbd},{0x2d,0xec},{0x23,0xfe},{0x1c,0x0f},
{0x22,0x01},{0x27,0x01},{0x1e,0x11},{0x14,0x26},{0x12,0x2d},{0x0f,0x36},
{0x00,0x4f},{0x24,0xf0},{0x25,0xf2},{0x25,0xef},{0x20,0x01},{0x22,0x0f},
{0x1d,0x0f},{0x18,0x19},{0x22,0x16},{0x1f,0x10},{0x23,0x12},{0x1f,0x1c},
{0x21,0x29},{0x24,0x1c},{0x1b,0x2f},{0x15,0x3e},{0x12,0x1f},{0x13,0x1a},
{0x24,0x18},{0x18,0x17},{0x1b,0x10},{0x18,0x1e},{0x1f,0x1d},{0x16,0x29},
{0x16,0x2a},{0x10,0x3c},{0x0f,0x34},{0x0e,0x3c},{0x03,0x4e},{0xf0,0x7b},
{0x15,0x35},{0x16,0x38},{0x19,0x3d},{0x15,0x21},{0x13,0x32},{0x11,0x3d},
{0xfd,0x4e},{0xf8,0x4a},{0xf7,0x48},{0xf6,0x48},{0xee,0x4b},{0xf4,0x47},
{0xf5,0x3f},{0xfb,0x46},{0xef,0x4b},{0xf2,0x48},{0xf0,0x43},{0xf8,0x35},
{0xf2,0x3b},{0xf7,0x34},{0xf5,0x44},{0x09,0xfe},{0x1e,0xf6},{0x1f,0xfc},
{0x21,0xff},{0x21,0x07},{0x1f,0x0c},{0x25,0x17},{0x1f,0x26},{0x14,0x40},
{0xf7,0x47},{0xf9,0x25},{0xf8,0x2c},{0xf5,0x31},{0xf6,0x38},{0xf4,0x3b},
{0xf8,0x3f},{0xf7,0x43},{0xfa,0x44},{0xf6,0x4f},{0xfd,0x4e},{0xf8,0x4a},
{0xf7,0x48},{0xf6,0x48},{0xee,0x4b},{0xf4,0x47},{0xf5,0x3f},{0xfb,0x46},
{0xef,0x4b},{0xf2,0x48},{0xf0,0x43},{0xf8,0x35},{0xf2,0x3b},{0xf7,0x34},
{0xf5,0x44},{0x09,0xfe},{0x1e,0xf6},{0x1f,0xfc},{0x21,0xff},{0x21,0x07},
{0x1f,0x0c},{0x25,0x17},{0x1f,0x26},{0x14,0x40},
    }
};

static inline void refill_cabac(VOCABACContext *c){
	c->low_bits+= (c->stream[0]<<9) + (c->stream[1]<<1);
	c->low_bits-= VO_CABAC_MASK;
	c->stream+= VO_CABAC_BITS/8;
}

static inline void refill2_cabac(VOCABACContext *c)
{
	int i, t;

	t= c->low_bits^ (c->low_bits-1);
#if defined(ARM) && defined(RVDS)
	__asm
	{
		CLZ i, t>>(VO_CABAC_BITS-1)
			RSB i, i, #30
	}
#elif defined(__GNUC__) &&  defined(ARM)
	__asm__ __volatile__ (
		"clz %0, %1 \n\t"
		"rsb %0, %0, #30"
		:"=r"(i)
		:"r"( t>>(VO_CABAC_BITS-1))
		);
#else
	i= 7 - vo_h264_norm_shift[t>>(VO_CABAC_BITS-1)];
#endif

	t= -VO_CABAC_MASK;

	t+= (c->stream[0]<<9) + (c->stream[1]<<1);

	c->low_bits+= t<<i;
	c->stream+= VO_CABAC_BITS/8;
}

static inline int vo_get_cabac(VOCABACContext *c, VO_U8* state)
{
	int s = *state;
	int RangeLPS= vo_h264_lps_range[2*(c->range&0xC0) + s];
	int val, lps_mask;

	c->range -= RangeLPS;

	lps_mask= ((c->range<<(VO_CABAC_BITS+1)) - c->low_bits)>>31;

	c->low_bits-= (c->range<<(VO_CABAC_BITS+1)) & lps_mask;
	c->range += (RangeLPS - c->range) & lps_mask;

	s^=lps_mask;
	*state= (vo_h264_mlps_state+128)[s];
	val= s&1;

#if defined(ARM) && defined(RVDS)
	__asm
	{
		CLZ lps_mask, c->range
			SUB lps_mask, lps_mask, #23
	}
#elif defined(__GNUC__) &&  defined(ARM)
	__asm__ __volatile__ (
		"clz %0, %1 \n\t"
		"sub %0, %0, #23"
		:"=r"(lps_mask)
		:"r"(c->range)
		);
#else
	lps_mask= vo_h264_norm_shift[c->range];
#endif
	c->range<<= lps_mask;
	c->low_bits<<= lps_mask;
	if(!(c->low_bits & VO_CABAC_MASK))
		refill2_cabac(c);
	return val;
}

static inline int vo_get_cabac_bypass(VOCABACContext *c)
{
	int val;
	c->low_bits+= c->low_bits;

	if(!(c->low_bits& VO_CABAC_MASK))
		refill_cabac(c);

	val= c->range<<(VO_CABAC_BITS+1);
	if(c->low_bits< val)
	{
		return 0;
	}
	else
	{
		c->low_bits-= val;
		return 1;
	}
}

static inline int vo_get_cabac_bypass_sign(VOCABACContext *c, int val)
{
	int range, mask;
	c->low_bits += c->low_bits;

	if(!(c->low_bits & VO_CABAC_MASK))
		refill_cabac(c);

	range= c->range<<(VO_CABAC_BITS+1);
	c->low_bits -= range;
	mask= c->low_bits >> 31;
	range &= mask;
	c->low_bits += range;
	return (val^mask)-mask;
}

static inline int vo_get_cabac_final(VOCABACContext *c)
{
	c->range -= 2;
	if(c->low_bits< c->range<<(VO_CABAC_BITS+1))
	{
		int shift= (VO_U32)(c->range - 0x100)>>31;
		c->range<<= shift;
		c->low_bits<<= shift;
		if(!(c->low_bits& VO_CABAC_MASK))
			refill_cabac(c);
		return 0;
	}
	else
	{
		return c->stream - c->stream_start;
	}
}





void vo_h264_init_cabac_states(Slice *currSlice) 
{
    int i;
    const VO_S8 (*tab)[2];

    if( currSlice->slice_type == I_SLICE) 
		tab = vo_cabac_init_I;
    else                                 
		tab = vo_cabac_init_PB[currSlice->model_number];

    /* calculate pre-state */
    for( i= 0; i < 460; i++ ) {
        int pre = 2*(((tab[i][0] * currSlice->qp) >>4 ) + tab[i][1]) - 127;

        pre^= pre>>31;
        if(pre > 124)
            pre= 124 + (pre&1);

        currSlice->cabac_ctx[i] =  pre;
    }
}


void cabac_new_slice(Slice *currSlice)
{
  currSlice->last_dquant = 0;
}


int readFieldModeInfo_CABAC(H264DEC_G *pDecGlobal,H264DEC_L *pDecLocal,VOCABACContext *dep_dp)
{  
  Slice *currSlice = pDecLocal->p_Slice;
  int top_mb_xy = pDecLocal->mb.y*pDecGlobal->PicWidthInMbs+pDecLocal->mb.x - 2L*pDecGlobal->PicWidthInMbs;
  int avab = (mb_is_available_mbaff(pDecGlobal,pDecLocal,top_mb_xy));
  int a = pDecLocal->mb.x? pDecLocal->mb_field: 0;
  int b = avab ? !!IS_INTERLACED(pDecGlobal->mb_type0_frame_buffer[top_mb_xy]): 0;
  int act_ctx = a + b;

  return vo_get_cabac( dep_dp, &(currSlice->cabac_ctx+70)[act_ctx] );
}


	void vo_init_cabac_states(){
#if 0		
		int i, j;
	
		for(i=0; i<64; i++){
			for(j=0; j<4; j++){ //FIXME check if this is worth the 1 shift we save
				vo_h264_lps_range[j*2*64+2*i+0]=
				vo_h264_lps_range[j*2*64+2*i+1]= rLPS_table_64x4[i][j];
			}
	
			vo_h264_mlps_state[128+2*i+0]=
			vo_h264_mps_state[2*i+0]= 2*AC_next_state_MPS_64[i]+0;
			vo_h264_mlps_state[128+2*i+1]=
			vo_h264_mps_state[2*i+1]= 2*AC_next_state_MPS_64[i]+1;
	
			if( i )
			{
				vo_h264_mlps_state[128-2*i-1]= 2*AC_next_state_LPS_64[i]+0;
				vo_h264_mlps_state[128-2*i-2]= 2*AC_next_state_LPS_64[i]+1;
			}else{
				vo_h264_mlps_state[128-2*i-1]= 1;
				vo_h264_mlps_state[128-2*i-2]= 0;
			}
		}
#endif		
	}

VO_S32 read_MVD_CABAC(H264DEC_L *pDecLocal, VOCABACContext *dep_dp,int n,short *mvd_cache,int k,short* st_mv)
{
  Slice *currSlice = pDecLocal->p_Slice;
  int base = 40+7*k;
  int a = mvd_cache[(n-1)*2+k] + mvd_cache[(n-8)*2+k];
  int act_ctx;
  int act_sym;  

  act_ctx = ((a-3)>>(31))+((a-33)>>(31))+2;

  if(!vo_get_cabac(dep_dp, &currSlice->cabac_ctx[base+act_ctx]))
  {
	*st_mv = 0;
    return 0;
  }

  act_sym= 1;
  base+= 3;
  while( act_sym < 9 && vo_get_cabac( dep_dp, &currSlice->cabac_ctx[base] ) ) 
  {
    if( act_sym < 4 )
      base++;
    act_sym++;
  }

  if( act_sym >= 9 ) 
  {
    int k = 3;
    while( vo_get_cabac_bypass( dep_dp ) ) 
	{
      act_sym += 1 << k;
      k++;
	  if(k>24)
	  	return 0;
    }
    while( k-- ) 
	{
      act_sym += vo_get_cabac_bypass( dep_dp )<<k;
    }
    *st_mv = act_sym < 70 ? act_sym : 70;
  }
  else
    *st_mv = act_sym;
  return vo_get_cabac_bypass_sign( dep_dp, -act_sym );

}

/*!
 ************************************************************************
 * \brief
 *    This function is used to arithmetically decode the 8x8 block type.
 ************************************************************************
 */
int readB8_typeInfo_CABAC_p_slice (H264DEC_L *pDecLocal,VOCABACContext *dep_dp)
{
  Slice *currSlice = pDecLocal->p_Slice;
  if( vo_get_cabac( dep_dp, &currSlice->cabac_ctx[21] ) )
    return 0;   /* 8x8 */
  if( !vo_get_cabac( dep_dp, &currSlice->cabac_ctx[22] ) )
    return 1;   /* 8x4 */
  if( vo_get_cabac( dep_dp, &currSlice->cabac_ctx[23] ) )
    return 2;   /* 4x8 */
  return 3;
}


/*!
 ************************************************************************
 * \brief
 *    This function is used to arithmetically decode the 8x8 block type.
 ************************************************************************
 */
int readB8_typeInfo_CABAC_b_slice (H264DEC_L *pDecLocal,VOCABACContext *dep_dp)
{
  Slice *currSlice = pDecLocal->p_Slice;
  int B8type = 3;

  if( !vo_get_cabac( dep_dp, &currSlice->cabac_ctx[36] ) )
    return 0;   /* B_Direct_8x8 */
  if( !vo_get_cabac( dep_dp, &currSlice->cabac_ctx[37] ) )
    return 1 + vo_get_cabac( dep_dp, &currSlice->cabac_ctx[39] ); /* B_L0_8x8, B_L1_8x8 */

  if( vo_get_cabac( dep_dp, &currSlice->cabac_ctx[38] ) ) 
  {
    if( vo_get_cabac( dep_dp, &currSlice->cabac_ctx[39] ) )
      return 11 + vo_get_cabac( dep_dp, &currSlice->cabac_ctx[39] ); /* B_L1_4x4, B_Bi_4x4 */
    B8type += 4;
  }
  B8type += 2*vo_get_cabac( dep_dp, &currSlice->cabac_ctx[39] );
  B8type +=   vo_get_cabac( dep_dp, &currSlice->cabac_ctx[39] );
  return B8type;
}

/*!
 ************************************************************************
 * \brief
 *    This function is used to arithmetically decode the macroblock
 *    type info of a given MB.
 ************************************************************************
 */
int read_skip_flag_CABAC(  H264DEC_G *pDecGlobal,H264DEC_L *pDecLocal,VOCABACContext *dep_dp,VO_S32 mbx,VO_S32 mby)
{
  Slice *currSlice = pDecLocal->p_Slice;
  int top_xy,left_xy,mb_xy;
  int act_ctx = 0;
  int avab;

  if(currSlice->mb_aff_frame_flag)
  { 
    int mb_field = pDecLocal->mb_field;
    mb_xy = mbx + (mby&~1)*pDecGlobal->PicWidthInMbs;
    left_xy = mb_xy - 1;
    if( (mby&1)&& mb_is_available_mbaff(pDecGlobal,pDecLocal,left_xy)&& mb_field == !!IS_INTERLACED(pDecGlobal->mb_type0_frame_buffer[left_xy]))
      left_xy += pDecGlobal->PicWidthInMbs;
    if( mb_field )
	{
      top_xy = mb_xy - pDecGlobal->PicWidthInMbs;
      if( !(mby&1)&&mb_is_available_mbaff(pDecGlobal,pDecLocal,top_xy)&&IS_INTERLACED(pDecGlobal->mb_type0_frame_buffer[top_xy]))
        top_xy -= pDecGlobal->PicWidthInMbs;
    }
	else
      top_xy = mbx + (mby-1)*pDecGlobal->PicWidthInMbs;
	
  }
  else
  {
    mb_xy = pDecLocal->mb_xy;
    top_xy = mb_xy-(pDecGlobal->PicWidthInMbs<<currSlice->field_pic_flag);
    left_xy = mb_xy-1;
	
  }
  avab = (mb_is_available_mbaff(pDecGlobal,pDecLocal,top_xy));
  act_ctx = ((mb_is_available_mbaff(pDecGlobal,pDecLocal,left_xy))&&pDecLocal->mb.x) ? (!IS_SKIP(pDecGlobal->mb_type0_frame_buffer[left_xy])) : 0;
  act_ctx += (avab) ? (!IS_SKIP(pDecGlobal->mb_type0_frame_buffer[top_xy])) : 0;
  

  if(currSlice->slice_type==B_SLICE)
  	act_ctx+=13;
  return( vo_get_cabac( dep_dp, &currSlice->cabac_ctx[11+act_ctx] ));

}

/*!
***************************************************************************
* \brief
*    This function is used to arithmetically decode the macroblock
*    intra_pred_size flag info of a given MB.
***************************************************************************
*/

int readMB_transform_size_flag_CABAC( H264DEC_L *pDecLocal,VOCABACContext *dep_dp)
{
  return vo_get_cabac( dep_dp, &pDecLocal->p_Slice->cabac_ctx[399 + pDecLocal->lu_transform8x8_flag] );
}

/*!
 ************************************************************************
 * \brief
 *    This function is used to arithmetically decode the macroblock
 *    type info of a given MB.
 ************************************************************************
 */
int readMB_typeInfo_CABAC_i_slice(H264DEC_L *pDecLocal,VOCABACContext *dep_dp)
{
  VO_U8 *state= &pDecLocal->p_Slice->cabac_ctx[3];
  int a = 0, b = 0;
  int act_ctx;
  int curr_mb_type = 0;

  if (pDecLocal->mbAvailB)
    b = !!(pDecLocal->top_type&6);

  if (pDecLocal->mbAvailA)
    a = !!(pDecLocal->left_type[0]&6);

  act_ctx = a + b;
  if( vo_get_cabac( dep_dp, &state[act_ctx] ) == 0 )
    return 0;   /* I4x4 */
  state += 2;
  if( vo_get_cabac_final( dep_dp ) )
    return 25;  /* PCM */

  curr_mb_type = 1; /* I16x16 */
  curr_mb_type += 12 * vo_get_cabac( dep_dp, &state[1] ); /* cbp_luma != 0 */
  if( vo_get_cabac( dep_dp, &state[2] ) ) /* cbp_chroma */
    curr_mb_type += 4 + 4 * vo_get_cabac( dep_dp, &state[2+1] );
  curr_mb_type += 2 * vo_get_cabac( dep_dp, &state[3+1] );
  curr_mb_type += 1 * vo_get_cabac( dep_dp, &state[3+2*1] );
  
  return curr_mb_type;
}


/*!
 ************************************************************************
 * \brief
 *    This function is used to arithmetically decode the macroblock
 *    type info of a given MB.
 ************************************************************************
 */
int readMB_typeInfo_CABAC_p_slice(H264DEC_L *pDecLocal,VOCABACContext *dep_dp,VO_S32* intra)
{
  Slice *currSlice = pDecLocal->p_Slice;
  int curr_mb_type;

  if( vo_get_cabac( dep_dp, &currSlice->cabac_ctx[14] ) == 0 ) 
  {
    if( vo_get_cabac( dep_dp, &currSlice->cabac_ctx[15] ) == 0 ) 
      curr_mb_type= 3 * vo_get_cabac( dep_dp, &currSlice->cabac_ctx[16] );
	else 
      curr_mb_type= 2 - vo_get_cabac( dep_dp, &currSlice->cabac_ctx[17] );
	curr_mb_type++;
  }
  else  // additional info for 16x16 Intra-mode
  {
    VO_U8 *state= &pDecLocal->p_Slice->cabac_ctx[17];
	*intra = 1;
	if( vo_get_cabac( dep_dp, state ) == 0 )
      return 6;
	if( vo_get_cabac_final( dep_dp ) )
      return 31;  /* PCM */

    curr_mb_type = 7; /* I16x16 */
    curr_mb_type += 12 * vo_get_cabac( dep_dp, &state[1] ); /* cbp_luma != 0 */
    if( vo_get_cabac( dep_dp, &state[2] ) ) /* cbp_chroma */
      curr_mb_type += 4 + 4 * vo_get_cabac( dep_dp, &state[2] );
    curr_mb_type += 2 * vo_get_cabac( dep_dp, &state[3] );
    curr_mb_type += 1 * vo_get_cabac( dep_dp, &state[3] );
  }

  return curr_mb_type;

}


/*!
 ************************************************************************
 * \brief
 *    This function is used to arithmetically decode the macroblock
 *    type info of a given MB.
 ************************************************************************
 */
int readMB_typeInfo_CABAC_b_slice(H264DEC_L *pDecLocal,VOCABACContext *dep_dp,VO_S32* intra)
{
  Slice *currSlice = pDecLocal->p_Slice;
  int a = 0, b = 0;
  int act_ctx;
  int curr_mb_type;

  if (pDecLocal->mbAvailB)
    b = !IS_DIRECT_VO( pDecLocal->top_type );

  if (pDecLocal->mbAvailA)
    a = !IS_DIRECT_VO( pDecLocal->left_type[0] );

  act_ctx = a + b;

  if( !vo_get_cabac( dep_dp, &currSlice->cabac_ctx[27+act_ctx] ) )
  {
    curr_mb_type= 0; /* B_Direct_16x16 */
  }
  else if( !vo_get_cabac( dep_dp, &currSlice->cabac_ctx[27+3] ) ) 
  {
    curr_mb_type= 1 + vo_get_cabac( dep_dp, &currSlice->cabac_ctx[27+5] ); /* B_L[01]_16x16 */
  }
  else
  {
    int act_sym;
    act_sym = vo_get_cabac( dep_dp, &currSlice->cabac_ctx[27+4] ) << 3;
    act_sym+= vo_get_cabac( dep_dp, &currSlice->cabac_ctx[27+5] ) << 2;
    act_sym+= vo_get_cabac( dep_dp, &currSlice->cabac_ctx[27+5] ) << 1;
    act_sym+= vo_get_cabac( dep_dp, &currSlice->cabac_ctx[27+5] );
    if( act_sym < 8 )
	{
      curr_mb_type= act_sym + 3; /* B_Bi_16x16 through B_L1_L0_16x8 */
    }
	else if( act_sym == 13 )
	{
      VO_U8 *state= &pDecLocal->p_Slice->cabac_ctx[32];
	  *intra = 1;
	  if( vo_get_cabac( dep_dp, state ) == 0 )
        return 23;
	  if( vo_get_cabac_final( dep_dp ) )
        return 48;  /* PCM */

      curr_mb_type = 24; /* I16x16 */
      curr_mb_type += 12 * vo_get_cabac( dep_dp, &state[1] ); /* cbp_luma != 0 */
      if( vo_get_cabac( dep_dp, &state[2] ) ) /* cbp_chroma */
        curr_mb_type += 4 + 4 * vo_get_cabac( dep_dp, &state[2] );
      curr_mb_type += 2 * vo_get_cabac( dep_dp, &state[3] );
      curr_mb_type += 1 * vo_get_cabac( dep_dp, &state[3] );
    }
	else if( act_sym == 14 )
    {
       curr_mb_type= 11; /* B_L1_L0_8x16 */
    }
	else if( act_sym == 15 )
    {
       curr_mb_type= 22; /* B_8x8 */
    }
	else
	{
       act_sym= ( act_sym<<1 ) + vo_get_cabac( dep_dp, &currSlice->cabac_ctx[27+5] );
       curr_mb_type= act_sym - 4; /* B_L0_Bi_* through B_Bi_Bi_* */
    }
  }
  return curr_mb_type;
}

/*!
 ************************************************************************
 * \brief
 *    This function is used to arithmetically decode a pair of
 *    intra prediction modes of a given MB.
 ************************************************************************
 */
int readIntraPredMode_CABAC( H264DEC_L *pDecLocal,VOCABACContext *dep_dp)
{
  Slice *currSlice = pDecLocal->p_Slice;
  int mode = 0;

  if( vo_get_cabac( dep_dp, &currSlice->cabac_ctx[68] ) )
        return -1;

  mode += 1 * vo_get_cabac( dep_dp, &currSlice->cabac_ctx[69] );
  mode += 2 * vo_get_cabac( dep_dp, &currSlice->cabac_ctx[69] );
  mode += 4 * vo_get_cabac( dep_dp, &currSlice->cabac_ctx[69] );
  return mode;
}


/*!
 ************************************************************************
 * \brief
 *    This function is used to arithmetically decode the reference
 *    parameter of a given MB.
 ************************************************************************
 */
int readRefFrame_CABAC(H264DEC_L *pDecLocal,VOCABACContext *dep_dp,int list,VO_S32 n)
{
  Slice *currSlice = pDecLocal->p_Slice;

  int   a = 0, b = 0;
  int   act_ctx;
  int   act_sym=0;
  if (!(pDecLocal->b8cache[n-1]))
  {
	a = (pDecLocal->ref_cache[list][n-1] > 0 ? 1 : 0);
  }
  if (!(pDecLocal->b8cache[n-8]))
  {
	b = (pDecLocal->ref_cache[list][n-8] > 0 ? 2 : 0);
  }


  act_ctx = a + b;
  while( vo_get_cabac( dep_dp, &currSlice->cabac_ctx[54+act_ctx] ) ) 
  {
    act_sym++;
    act_ctx = (act_ctx>>2)+4;
    if(act_sym >= 32 )
      return -1;
  }
  return act_sym;
}

VO_S32 readRefFrame_CABAC_p_slice(H264DEC_L *pDecLocal,VOCABACContext *dep_dp,int n,VO_S8 *ref_cache)
{
  Slice *currSlice = pDecLocal->p_Slice;

  int   act_ctx = 0;
  int   act_sym = 0;

  if(ref_cache[n-1] > 0 )
  	act_ctx++;
  if(ref_cache[n-8] > 0 )
  	act_ctx+=2;
  
  while( vo_get_cabac( dep_dp, &currSlice->cabac_ctx[54+act_ctx] ) ) 
  {
    act_sym++;
    act_ctx = (act_ctx>>2)+4;
    if(act_sym >= 32 )
      return -1;
  }
  return act_sym;
}

/*!
 ************************************************************************
 * \brief
 *    This function is used to arithmetically decode the delta qp
 *     of a given MB.
 ************************************************************************
 */
int read_dQuant_CABAC( Slice *currSlice,VOCABACContext *dep_dp)
{
  int dquant = 0 ;
  int act_ctx = ((currSlice->last_dquant != 0) ? 1 : 0);

  if (vo_get_cabac( dep_dp, &currSlice->cabac_ctx[60 + act_ctx]))
  {
     dquant = 1;
     act_ctx= 2;

     while( vo_get_cabac( dep_dp, &currSlice->cabac_ctx[60 + act_ctx] ) ) 
	 {
       act_ctx= 3;
       dquant++;
	   if(dquant>53)//warning_dtt
	   	return dquant;
     }

     if( dquant&0x01 )
       dquant = (dquant + 1)>>1 ;
     else
       dquant= -((dquant + 1)>>1);
  }

  currSlice->last_dquant = dquant;

  return dquant;
}
/*!
 ************************************************************************
 * \brief
 *    This function is used to arithmetically decode the coded
 *    block pattern of a given MB.
 ************************************************************************
 */
int read_CBP_CABAC(H264DEC_L *pDecLocal,VOCABACContext *dep_dp)
{
  Slice *currSlice = pDecLocal->p_Slice;

  int cbp = 0,cbp_up,cbp_left,cbp_c;
  int act_ctx;
  cbp_left = pDecLocal->cbp_left;
  cbp_up = pDecLocal->cbp_up;

  act_ctx = !(cbp_left & 0x02) + 2 * !(cbp_up & 0x04);
  cbp += vo_get_cabac(dep_dp, &currSlice->cabac_ctx[73 + act_ctx]);
  act_ctx = !(cbp   & 0x01) + 2 * !(cbp_up & 0x08);
  cbp += vo_get_cabac(dep_dp, &currSlice->cabac_ctx[73 + act_ctx]) << 1;
  act_ctx = !(cbp_left & 0x08) + 2 * !(cbp   & 0x01);
  cbp += vo_get_cabac(dep_dp, &currSlice->cabac_ctx[73 + act_ctx]) << 2;
  act_ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);
  cbp += vo_get_cabac(dep_dp, &currSlice->cabac_ctx[73 + act_ctx]) << 3;

  cbp_left = (pDecLocal->cbp_left>>4)&0x03;
  cbp_up = (pDecLocal-> cbp_up>>4)&0x03;

  act_ctx = 0;
  if( cbp_left > 0 ) 
  	act_ctx++;
  if( cbp_up > 0 ) 
  	act_ctx += 2;
  if( vo_get_cabac( dep_dp, &currSlice->cabac_ctx[77 + act_ctx] ) == 0 )
    cbp_c = 0;
  else
  {
    act_ctx = 4;
    if( cbp_left == 2 ) 
  	  act_ctx++;
    if( cbp_up == 2 ) 
  	  act_ctx += 2;
    cbp_c = 1 + vo_get_cabac( dep_dp, &currSlice->cabac_ctx[77 + act_ctx] );
  }
  cbp |= cbp_c<<4;
  if (!cbp)
  {
    currSlice->last_dquant = 0;
  }
  return cbp;
  
}

/*!
 ************************************************************************
 * \brief
 *    This function is used to arithmetically decode the chroma
 *    intra prediction mode of a given MB.
 ************************************************************************
 */
int readCIPredMode_CABAC(H264DEC_G *pDecGlobal,H264DEC_L *pDecLocal,VOCABACContext *dep_dp)
{
  Slice *currSlice = pDecLocal->p_Slice;
  //int mbx = pDecLocal->mb.x;

  //int b = (pDecLocal->mbAvailB)   ? (((pDecGlobal->c_ipred_frame_buffer[pDecLocal->top_mb_xy]!= 0)) ? 1 : 0) : 0;
  //int a = (pDecLocal->mbAvailA) ? (((pDecGlobal->c_ipred_frame_buffer[pDecLocal->left_mb_xy[0]]!= 0)) ? 1 : 0) : 0;
  //int act_ctx = a + b;
  int act_ctx = 0;
  if(pDecLocal->mbAvailB&&pDecGlobal->c_ipred_frame_buffer[pDecLocal->top_mb_xy]!= 0)
  	act_ctx++;
  if(pDecLocal->mbAvailA&&pDecGlobal->c_ipred_frame_buffer[pDecLocal->left_mb_xy[0]]!= 0)
  	act_ctx++;

  if( vo_get_cabac( dep_dp, &currSlice->cabac_ctx[64+act_ctx] ) == 0 )
    return 0;

  if( vo_get_cabac( dep_dp, &currSlice->cabac_ctx[64+3] ) == 0 )
    return 1;
  if( vo_get_cabac( dep_dp, &currSlice->cabac_ctx[64+3] ) == 0 )
    return 2;
  else
    return 3;

}


static const int vo_significant_coeff_flag_offset[2][6] = 
{
  { 105, 120, 134, 149, 152, 402 },
  { 277, 292, 306, 321, 324, 436 }
};

static const int vo_last_coeff_flag_offset[2][6] = 
{
  { 166, 181, 195, 210, 213, 417 },
  { 338, 353, 367, 382, 385, 451 }
};
static const int vo_coeff_abs_level_m1_offset[6] = 
{
    227, 237, 247, 257, 266, 426
};
static const VO_U8 vo_significant_coeff_flag_offset_8x8[2][63] = 
{
  { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x05, 0x04, 0x04, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05,
    0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x06, 0x07, 0x07, 0x07, 0x08, 0x09,0x0a, 0x09, 0x08, 0x07,
    0x07, 0x06,0x0b,0x0c,0x0d,0x0b, 0x06, 0x07, 0x08, 0x09,0x0e,0x0a, 0x09, 0x08, 0x06,0x0b,
   0x0c,0x0d,0x0b, 0x06, 0x09,0x0e,0x0a, 0x09,0x0b,0x0c,0x0d,0x0b,0x0e,0x0a,0x0c },
  { 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x07, 0x08, 0x04, 0x05,
    0x06, 0x09,0x0a,0x0a, 0x08,0x0b,0x0c,0x0b, 0x09, 0x09,0x0a,0x0a, 0x08,0x0b,0x0c,0x0b,
    0x09, 0x09,0x0a,0x0a, 0x08,0x0b,0x0c,0x0b, 0x09, 0x09,0x0a,0x0a, 0x08,0x0d,0x0d, 0x09,
    0x09,0x0a,0x0a, 0x08,0x0d,0x0d, 0x09, 0x09,0x0a,0x0a,0x0e,0x0e,0x0e,0x0e,0x0e }
};
static const VO_U8 vo_last_coeff_flag_offset_8x8[64] = 
{
    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08
};

static const VO_U8 vo_coeff_abs_level1_ctx[8] = { 0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00 };
static const VO_U8 vo_coeff_abs_levelgt1_ctx[8] = { 0x05, 0x05, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09 };
static const VO_U8 vo_coeff_abs_level_transition[2][8] = 
{
  { 0x01, 0x02, 0x03, 0x03, 0x04, 0x05, 0x06, 0x07 },
  { 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x07 }
};


static  int vo_get_cabac_cbpbit_ctx( H264DEC_L *pDecLocal, int val, int n, int dc ) 
{
  int nz_left, nz_up;
  int act_ctx = 0;

  if( dc ) 
  {
    if( val == 0 ) 
	{
      nz_left = pDecLocal->cbp_left&0x100;
      nz_up = pDecLocal->cbp_up&0x100;
    } 
	else 
	{
      nz_left = (pDecLocal->cbp_left>>(6+n))&0x01;
      nz_up = (pDecLocal->cbp_up>>(6+n))&0x01;
    }
  } 
  else 
  {
    nz_left = pDecLocal->nz_coeff[cache_scan[n] - 1];
    nz_up = pDecLocal->nz_coeff[cache_scan[n] - 8];
  }

  if( nz_left > 0 )
    act_ctx++;

  if( nz_up > 0 )
    act_ctx += 2;

  return act_ctx + 4 * val;
}

/*!
 ************************************************************************
 * \brief
 *    Read Block-Transform Coefficients
 ************************************************************************
 */
void readRunLevel_CABAC (H264DEC_L *pDecLocal, int type,VOCABACContext *dep_dp,short *cof,int dc,int idx,int max,const VO_U8 *scan,int* inv,int qp_per)
{
  Slice *currSlice = pDecLocal->p_Slice;
  int act_ctx,last;
  VO_U8 *vo_significant_coeff_ctx_base;
  VO_U8 *vo_last_coeff_ctx_base;
  VO_U8 *vo_abs_level_m1_ctx_base;
  VO_S32 coeff[16];
  int count = 0;
  int node_ctx = 0;
  int mb_field = (currSlice->field_pic_flag||pDecLocal->mb_field)?1:0;
  VOCABACContext in_c;
  in_c.range      = dep_dp->range;
  in_c.low_bits   = dep_dp->low_bits;
  in_c.stream     = dep_dp->stream;
  //--- read coefficients for whole block ---
  //if (*coeff_ctr < 0)
  {
    //===== decode CBP-BIT =====
    act_ctx = vo_get_cabac_cbpbit_ctx(pDecLocal,type ,idx,dc);
    if (vo_get_cabac( &in_c, &currSlice->cabac_ctx[85 + act_ctx ] ) != 0)
    {
      //===== decode significance map =====
      vo_significant_coeff_ctx_base = currSlice->cabac_ctx + vo_significant_coeff_flag_offset[mb_field][type];
      vo_last_coeff_ctx_base = currSlice->cabac_ctx + vo_last_coeff_flag_offset[mb_field][type];
      vo_abs_level_m1_ctx_base = currSlice->cabac_ctx + vo_coeff_abs_level_m1_offset[type];
      //*coeff_ctr = read_significance_map (pDecLocal, dep_dp, se->context, currSlice->coeff);
      for(last= 0; last < max -1; last++) 
	  { 
        VO_U8 *sig_ctx = vo_significant_coeff_ctx_base + last; 
        if( vo_get_cabac( &in_c, sig_ctx )) 
		{ 
          VO_U8 *last_ctx = vo_last_coeff_ctx_base + last; 
          coeff[count++] = last; 
          if( vo_get_cabac( &in_c, last_ctx) ) 
		  { 
            last= max; 
            break; 
          } 
        } 
      }
      if( last == max -1 )
        coeff[count++] = last;
	  
	  if( dc ) 
	  {
        if( type == 0 )
          pDecLocal->cbp |= 0x100;
        else
          pDecLocal->cbp |= 0x40 << idx;
      }
	  else
	    pDecLocal->nz_coeff[cache_scan[idx]] = count;
      //===== decode significant coefficients =====
      //read_significant_coefficients    (dep_dp, currSlice->tex_ctx, se->context, currSlice->coeff);
      do 
	  {
        VO_U8 *ctx = vo_coeff_abs_level1_ctx[node_ctx] + vo_abs_level_m1_ctx_base;

        int j = scan[coeff[--count]];

        if( vo_get_cabac( &in_c, ctx ) == 0 ) 
		{
          node_ctx = vo_coeff_abs_level_transition[0][node_ctx];
		  if(dc)
            cof[j] = vo_get_cabac_bypass_sign( &in_c, -1);
		  else
		  	cof[j] = (short)rshift_rnd_sf((vo_get_cabac_bypass_sign( &in_c, -1) * inv[j]) << qp_per, 4);
        } 
		else 
		{
            int coeff_abs = 2;
            ctx = vo_coeff_abs_levelgt1_ctx[node_ctx] + vo_abs_level_m1_ctx_base;
            node_ctx = vo_coeff_abs_level_transition[1][node_ctx];

            while( coeff_abs < 15 && vo_get_cabac( &in_c, ctx ) ) {
                coeff_abs++;
            }

            if( coeff_abs >= 15 ) {
                int j = 0;
                while( vo_get_cabac_bypass( &in_c ) ) {
                    j++;
                }

                coeff_abs=1;
                while( j-- ) {
                    coeff_abs += coeff_abs + vo_get_cabac_bypass( &in_c );
                }
                coeff_abs+= 14;
            }
			if(dc)
              cof[j] = vo_get_cabac_bypass_sign( &in_c, -coeff_abs );
			else
			  cof[j] = (short)rshift_rnd_sf((vo_get_cabac_bypass_sign( &in_c, -coeff_abs ) * inv[j]) << qp_per, 4);
        }
      } while( count );
    }
  }
  dep_dp->range     = in_c.range;
  dep_dp->low_bits  = in_c.low_bits;
  dep_dp->stream    = in_c.stream;
}

void readRunLevel_CABAC_8x8 (H264DEC_L *pDecLocal,VOCABACContext *dep_dp,short *cof,int idx,const VO_U8 *scan,int* inv,int qp_per)
{
  Slice *currSlice = pDecLocal->p_Slice;
  int last;
  VO_U8 *vo_significant_coeff_ctx_base;
  VO_U8 *vo_last_coeff_ctx_base;
  VO_U8 *vo_abs_level_m1_ctx_base;
  VO_S32 coeff[64];
  int count = 0;
  int node_ctx = 0;
  int mb_field = (currSlice->field_pic_flag||pDecLocal->mb_field)?1:0;
  const VO_U8 *sig_off = vo_significant_coeff_flag_offset_8x8[mb_field];
  VOCABACContext in_c;
  in_c.range      = dep_dp->range;
  in_c.low_bits   = dep_dp->low_bits;
  in_c.stream     = dep_dp->stream;

  //===== decode significance map =====
  vo_significant_coeff_ctx_base = currSlice->cabac_ctx + vo_significant_coeff_flag_offset[mb_field][5];
  vo_last_coeff_ctx_base = currSlice->cabac_ctx + vo_last_coeff_flag_offset[mb_field][5];
  vo_abs_level_m1_ctx_base = currSlice->cabac_ctx + vo_coeff_abs_level_m1_offset[5];
  
      //*coeff_ctr = read_significance_map (pDecLocal, dep_dp, se->context, currSlice->coeff);
  for(last= 0; last < 63; last++) 
  { 
    VO_U8 *sig_ctx = vo_significant_coeff_ctx_base + sig_off[last]; 
    if( vo_get_cabac( &in_c, sig_ctx )) 
	{ 
      VO_U8 *last_ctx = vo_last_coeff_ctx_base + vo_last_coeff_flag_offset_8x8[last]; 
      coeff[count++] = last; 
      if( vo_get_cabac( &in_c, last_ctx) ) 
	  { 
        last= 64; 
        break; 
      } 
    } 
  }
  if( last == 63 )
    coeff[count++] = last;
	  
  pDecLocal->nz_coeff[cache_scan[idx]]=pDecLocal->nz_coeff[cache_scan[idx]+1]= 
  pDecLocal->nz_coeff[cache_scan[idx]+8]=pDecLocal->nz_coeff[cache_scan[idx]+9]	= count;
      //===== decode significant coefficients =====
      //read_significant_coefficients    (dep_dp, currSlice->tex_ctx, se->context, currSlice->coeff);
      do 
	  {
        VO_U8 *ctx = vo_coeff_abs_level1_ctx[node_ctx] + vo_abs_level_m1_ctx_base;

        int j = scan[coeff[--count]];

        if( vo_get_cabac( &in_c, ctx ) == 0 ) 
		{
          node_ctx = vo_coeff_abs_level_transition[0][node_ctx];
		  cof[j] = (short)rshift_rnd_sf((vo_get_cabac_bypass_sign( &in_c, -1) * inv[j]) << qp_per, 6);
        } 
		else 
		{
          int coeff_abs = 2;
          ctx = vo_coeff_abs_levelgt1_ctx[node_ctx] + vo_abs_level_m1_ctx_base;
          node_ctx = vo_coeff_abs_level_transition[1][node_ctx];

          while( coeff_abs < 15 && vo_get_cabac( &in_c, ctx ) ) {
            coeff_abs++;
          }

          if( coeff_abs >= 15 ) {
            int j = 0;
            while( vo_get_cabac_bypass( &in_c ) ) {
              j++;
            }

            coeff_abs=1;
            while( j-- ) {
              coeff_abs += coeff_abs + vo_get_cabac_bypass( &in_c );
            }
            coeff_abs+= 14;
          }
	      cof[j] = (short)rshift_rnd_sf((vo_get_cabac_bypass_sign( &in_c, -coeff_abs ) * inv[j]) << qp_per, 6);
        }
      } while( count );

  dep_dp->range     = in_c.range;
  dep_dp->low_bits  = in_c.low_bits;
  dep_dp->stream    = in_c.stream;
}


int cabac_startcode_follows(H264DEC_G *pDecGlobal,Slice *currSlice, int eos_bit)
{
  unsigned int  bit;

  if( eos_bit )
  {
    //const byte   *partMap    = assignSE2partition[currSlice->dp_mode];
    DataPartition *dP = &currSlice->partArr[0];  

    bit = vo_get_cabac_final (&(dP->c)); //GB
  }
  else
  {
    bit = 0;
  }

  return (bit ? 1 : 0);
}


